<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Minecraft HTML5 - Corrig√©</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }

        #ui {
            position: absolute; top: 12px; left: 12px;
            color: #fff; background: rgba(0,0,0,0.55);
            padding: 10px 14px; border-radius: 8px;
            pointer-events: none; user-select: none;
            font-size: 13px; line-height: 1.7;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(4px);
        }
        #ui b { color: #7ee8a2; font-size: 14px; }
        #debug { color: #adf; font-size: 12px; margin-top: 4px; }

        /* ---- PANNEAU DROITE ---- */
        #side-panel {
            position: absolute; top: 12px; right: 12px;
            display: flex; flex-direction: column; gap: 10px;
            z-index: 20;
        }

        .panel-box {
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px; padding: 10px 14px;
            color: #fff; font-size: 13px;
            backdrop-filter: blur(6px);
            min-width: 190px;
        }
        .panel-title {
            font-weight: 700; font-size: 13px; color: #ffd87a;
            margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 4px;
        }
        .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
        .btn {
            flex: 1; padding: 5px 8px; cursor: pointer;
            background: rgba(255,255,255,0.1); color: #fff;
            border: 1px solid rgba(255,255,255,0.25); border-radius: 5px;
            font-size: 12px; transition: background 0.15s;
            white-space: nowrap;
        }
        .btn:hover { background: rgba(255,255,255,0.25); }
        .btn.danger { border-color: rgba(255,80,80,0.5); }
        .btn.danger:hover { background: rgba(255,80,80,0.3); }
        .btn.success { border-color: rgba(80,220,120,0.5); }
        .btn.success:hover { background: rgba(80,220,120,0.2); }

        #save-status { font-size: 11px; color: #aaa; margin-top: 6px; min-height: 16px; }

        .slider-row { display: flex; align-items: center; gap: 8px; margin-top: 4px; }
        .slider-row label { font-size: 12px; color: #ccc; min-width: 70px; }
        .slider-row input[type=range] { flex: 1; accent-color: #7ee8a2; cursor: pointer; }
        .slider-row span { min-width: 18px; text-align: right; font-size: 12px; color: #fff; }

        /* Hotbar */
        #hotbar {
            position: absolute; bottom: 14px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 4px; z-index: 20;
            pointer-events: none;
        }
        .hotslot {
            width: 46px; height: 46px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 6px; display: flex;
            align-items: center; justify-content: center;
            font-size: 18px; color: #fff;
            transition: border-color 0.1s;
        }
        .hotslot.active { border-color: #fff; background: rgba(255,255,255,0.15); }

        /* Overlay */
        #overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.75);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #fff; z-index: 100;
            transition: opacity 0.3s;
        }
        #overlay h1 { font-size: 2.2em; margin-bottom: 8px; color: #7ee8a2; }
        #overlay p { color: #aaa; font-size: 14px; margin: 4px 0; }
        #overlay .play-btn {
            margin-top: 20px; padding: 12px 36px;
            background: #7ee8a2; color: #000;
            border: none; border-radius: 8px;
            font-size: 16px; font-weight: 700; cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px 20px rgba(126,232,162,0.4);
        }
        #overlay .play-btn:hover { transform: scale(1.04); }
        #overlay.hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

<div id="overlay">
    <h1>‚õè Minecraft Corrig√©</h1>
    <p>üéÆ ZQSD : Se d√©placer | Shift : Sprinter</p>
    <p>‚å® C : Casser | V : Poser</p>
    <p>Space : Sauter | 1-8 : Changer de bloc</p>
    <button class="play-btn" id="btn-play">‚ñ∂ Jouer</button>
</div>

<div id="crosshair"></div>

<div id="ui">
    <b>‚õè Minecraft Corrig√©</b><br>
    ZQSD ¬∑ Space (Saut) ¬∑ Shift (Sprint)<br>
    C (Casser) ¬∑ V (Poser)<br>
    <div id="debug">Init...</div>
</div>

<div id="side-panel">
    <div class="panel-box">
        <div class="panel-title">üíæ Sauvegarde</div>
        <div class="btn-row">
            <button class="btn success" id="btn-save">üíæ Sauver</button>
            <button class="btn" id="btn-load">üìÇ Charger</button>
        </div>
        <div class="btn-row" style="margin-top:5px">
            <button class="btn danger" id="btn-new">üåç Nouveau</button>
        </div>
        <div id="save-status">Aucune sauvegarde</div>
    </div>
    <div class="panel-box">
        <div class="panel-title">‚öôÔ∏è Rendu</div>
        <div class="slider-row">
            <label>Distance</label>
            <input type="range" id="slider-dist" min="1" max="6" value="2" step="1">
            <span id="dist-val">2</span>
        </div>
        <div class="slider-row">
            <label>Qualit√©</label>
            <input type="range" id="slider-quality" min="0" max="2" value="1" step="1">
            <span id="quality-val">Moyen</span>
        </div>
    </div>
</div>

<div id="hotbar">
    <div class="hotslot active">üå±</div>
    <div class="hotslot">ü™®</div>
    <div class="hotslot">üü´</div>
    <div class="hotslot">ü™µ</div>
    <div class="hotslot">üåø</div>
    <div class="hotslot">‚¨õ</div>
    <div class="hotslot">üî∂</div>
    <div class="hotslot">üíé</div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { createNoise2D, createNoise3D } from 'simplex-noise';

// ============================================================
// CONFIGURATION TEXTURES (CORRIG√âE : LIENS STABLES)
// ============================================================
const BASE_URL = "https://threejs.org/examples/textures/minecraft/"; // Liens officiels Three.js

const TEXTURES_FILES = {
    dirt:           "https://static.planetminecraft.com/files/resource_media/screenshot/1236/pack_3530346.jpg",
    grass_top:      "https://cdn.modrinth.com/data/wcxzqGUc/8a127e882e07a03d29e62d44671a2359ef7b336b.png",
    grass_side:     "Textures/grass_side.png",
    stone:          "https://threejs.org/examples/textures/uv_grid_opengl.jpg", // Placeholder stable pour pierre
    wood:           "https://threejs.org/examples/textures/crate.gif",
    leaves:         BASE_URL + "grass.png", // R√©utilisation herbe pour feuillage (vert)
    coal_ore:       BASE_URL + "dirt.png", 
    iron_ore:       BASE_URL + "dirt.png",
    diamond_ore:    BASE_URL + "dirt.png",
    crafting_table: "https://threejs.org/examples/textures/crate.gif"
};

// ============================================================
// PARAM√àTRES MONDE
// ============================================================
const CHUNK_SIZE    = 16;
let   RENDER_DIST   = 2;
const MAX_Y         = 40;

const noise2D = createNoise2D();
const noise3D = createNoise3D();

// ============================================================
// VARIABLES GLOBALES
// ============================================================
let camera, scene, renderer, controls;
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let isSprinting = false; 
let velocity = new THREE.Vector3(); // Vecteur de vitesse complet
let canJump = false;
let armMesh;

const direction = new THREE.Vector3();

// Donn√©es du monde
let playerMods = {};       
let proceduralCache = {};  
const chunks = {};         
const materials = {};      

const PLACE_BLOCKS = ['grass','stone','dirt','wood','leaves','coal','iron','diamond'];
let activeSlot = 0;

let fps=0, frameCount=0, lastFpsTime=0;
let lastChunkTick = 0;
let savedWorld = null;

// ============================================================
// G√âN√âRATION PROC√âDURALE
// ============================================================
function seededRand(x, z, seed = 0) {
    let n = Math.sin(x * 127.1 + z * 311.7 + seed * 74.7) * 43758.5453;
    return n - Math.floor(n);
}

function getSurfaceHeight(wx, wz) {
    const n = noise2D(wx * 0.02, wz * 0.02);
    return Math.floor((n + 1) * 0.5 * 10) + 10; 
}

function getBaseBlock(x, y, z) {
    if (y < 0) return null;
    const h = getSurfaceHeight(x, z);
    if (y > h) return null;
    if (y === 0) return 'stone'; 

    if (y < 15) {
        const cn = noise3D(x * 0.05, y * 0.05, z * 0.05);
        if (cn < -0.3) return null;
    }

    if (y === h) return 'grass';
    if (y > h - 4) return 'dirt';

    const r = seededRand(x, z, y);
    if (r < 0.005 && y < 10) return 'diamond';
    if (r < 0.02  && y < 20) return 'iron';
    if (r < 0.03)             return 'coal';
    return 'stone';
}

function buildProceduralCache(cx, cz) {
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;
    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
            const wx = sx + lx, wz = sz + lz;
            const h  = getSurfaceHeight(wx, wz);

            if (seededRand(wx, wz, 99) < 0.001) {
                const k = `${wx},${h+1},${wz}`;
                if (!proceduralCache[k] && !(k in playerMods)) proceduralCache[k] = 'crafting';
            }

            if (seededRand(wx, wz, 0) < 0.01) {
                const tH = 4 + Math.floor(seededRand(wx, wz, 1) * 2);
                for (let i = 1; i <= tH; i++) {
                    const k = `${wx},${h+i},${wz}`;
                    if (!proceduralCache[k] && !(k in playerMods)) proceduralCache[k] = 'wood';
                }
                for (let fX = -2; fX <= 2; fX++)
                for (let fY = 0; fY <= 2;  fY++)
                for (let fZ = -2; fZ <= 2; fZ++) {
                    if (Math.abs(fX)+Math.abs(fY)+Math.abs(fZ) > 3) continue;
                    if (fX===0 && fZ===0 && fY < tH-1) continue;
                    const k = `${wx+fX},${h+tH+fY-1},${wz+fZ}`;
                    if (!proceduralCache[k] && !(k in playerMods)) proceduralCache[k] = 'leaves';
                }
            }
        }
    }
}

function getBlock(x, y, z) {
    const k = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
    if (k in playerMods)      return playerMods[k];       
    if (k in proceduralCache) return proceduralCache[k];
    return getBaseBlock(Math.floor(x), Math.floor(y), Math.floor(z));
}

function setBlock(x, y, z, type) {
    x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
    const k = `${x},${y},${z}`;
    const base = proceduralCache[k] ?? getBaseBlock(x, y, z);

    if (type === base) { delete playerMods[k]; }
    else               { playerMods[k] = type; }

    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const markDirty = (a,b) => { if (chunks[`${a},${b}`]) chunks[`${a},${b}`].dirty = true; };
    markDirty(cx, cz);
    if ((x - cx*CHUNK_SIZE) === 0)             markDirty(cx-1, cz);
    if ((x - cx*CHUNK_SIZE) === CHUNK_SIZE-1)  markDirty(cx+1, cz);
    if ((z - cz*CHUNK_SIZE) === 0)             markDirty(cx, cz-1);
    if ((z - cz*CHUNK_SIZE) === CHUNK_SIZE-1)  markDirty(cx, cz+1);
}

// ============================================================
// CHARGEMENT DES MAT√âRIAUX (CORRIG√â)
// ============================================================
function loadMaterials() {
    const loader = new THREE.TextureLoader();
    const loadTex = (url) => {
        const t = loader.load(url);
        t.magFilter = t.minFilter = THREE.NearestFilter;
        t.colorSpace = THREE.SRGBColorSpace;
        return t;
    };
    
    // Fonction helper pour cr√©er un material
    const mat = (url, color=0xffffff) => new THREE.MeshLambertMaterial({ map: loadTex(url), color: color });
    const col = (c) => new THREE.MeshLambertMaterial({ color: c });

    // Textures pr√©charg√©es
    const tDirt = loadTex(TEXTURES_FILES.dirt);
    const tGrassTop = loadTex(TEXTURES_FILES.grass_top);
    const tGrassSide = loadTex(TEXTURES_FILES.grass_side);
    const tStone = loadTex(TEXTURES_FILES.stone);
    const tWood = loadTex(TEXTURES_FILES.wood);

    // Ordre des faces ThreeJS : Right, Left, Top, Bottom, Front, Back
    materials.grass = [
        new THREE.MeshLambertMaterial({ map: tGrassSide }), // Right
        new THREE.MeshLambertMaterial({ map: tGrassSide }), // Left
        new THREE.MeshLambertMaterial({ map: tGrassTop }),  // Top (C'est ici qu'on corrige l'invisible)
        new THREE.MeshLambertMaterial({ map: tDirt }),      // Bottom
        new THREE.MeshLambertMaterial({ map: tGrassSide }), // Front
        new THREE.MeshLambertMaterial({ map: tGrassSide })  // Back
    ];
    
    const simple = (m) => [m,m,m,m,m,m];

    materials.dirt     = simple(new THREE.MeshLambertMaterial({ map: tDirt }));
    materials.stone    = simple(new THREE.MeshLambertMaterial({ map: tStone, color: 0xaaaaaa }));
    materials.wood     = simple(new THREE.MeshLambertMaterial({ map: tWood }));
    materials.leaves   = simple(col(0x228B22)); // Couleur unie pour perf et visibilit√©
    materials.coal     = simple(col(0x333333));
    materials.iron     = simple(col(0xCD853F));
    materials.diamond  = simple(col(0x00FFFF));
    materials.crafting = simple(new THREE.MeshLambertMaterial({ map: tWood, color: 0xEBC49F }));
}

// ============================================================
// MOTEUR DE RENDU (CHUNKS)
// ============================================================
const FACES = [
    { dir:[1,0,0],  corners:[[1,0,1],[1,1,1],[1,1,0],[1,0,0]],  faceIdx:0 }, // Right
    { dir:[-1,0,0], corners:[[0,0,0],[0,1,0],[0,1,1],[0,0,1]],  faceIdx:1 }, // Left
    { dir:[0,1,0],  corners:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]],  faceIdx:2 }, // Top
    { dir:[0,-1,0], corners:[[0,0,1],[1,0,1],[1,0,0],[0,0,0]],  faceIdx:3 }, // Bottom
    { dir:[0,0,1],  corners:[[0,0,1],[0,1,1],[1,1,1],[1,0,1]],  faceIdx:4 }, // Front
    { dir:[0,0,-1], corners:[[1,0,0],[1,1,0],[0,1,0],[0,0,0]],  faceIdx:5 }, // Back
];

function buildChunk(cx, cz) {
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;
    const matBuckets = new Map();

    const getBucket = (mat) => {
        const uuid = mat.uuid;
        if (!matBuckets.has(uuid)) {
            matBuckets.set(uuid, { mat, pos:[], nor:[], uv:[], idx:[], vc:0 });
        }
        return matBuckets.get(uuid);
    };

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
    for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        const wx = sx + lx;
        const wz = sz + lz;

        for (let y = 0; y <= MAX_Y; y++) {
            const type = getBlock(wx, y, wz);
            if (!type) continue;

            const matArr = materials[type] || materials.stone;

            FACES.forEach(({ dir, corners, faceIdx }) => {
                const nx = wx + dir[0];
                const ny =  y + dir[1];
                const nz = wz + dir[2];
                if (getBlock(nx, ny, nz)) return; // Face cach√©e

                const mat = matArr[faceIdx];
                const b = getBucket(mat);
                const base = b.vc;

                corners.forEach(([cx2, cy, cz2]) => {
                    b.pos.push(wx + cx2 - 0.5, y + cy - 0.5, wz + cz2 - 0.5);
                    b.nor.push(...dir);
                });
                b.uv.push(0,0, 0,1, 1,1, 1,0);
                b.idx.push(base, base+1, base+2, base, base+2, base+3);
                b.vc += 4;
            });
        }
    }}

    const meshes = [];
    matBuckets.forEach(({ mat, pos, nor, uv, idx }) => {
        if (idx.length === 0) return;
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('normal',   new THREE.Float32BufferAttribute(nor, 3));
        geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uv,  2));
        geo.setIndex(idx);
        const mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);
        meshes.push(mesh);
    });
    return meshes;
}

function disposeChunk(key) {
    if (!chunks[key]) return;
    chunks[key].meshes.forEach(m => { scene.remove(m); m.geometry.dispose(); });
    chunks[key].meshes = [];
}

function updateChunks() {
    const px = Math.floor(camera.position.x / CHUNK_SIZE);
    const pz = Math.floor(camera.position.z / CHUNK_SIZE);

    for (let dx = -RENDER_DIST; dx <= RENDER_DIST; dx++) {
    for (let dz = -RENDER_DIST; dz <= RENDER_DIST; dz++) {
        const cx = px+dx, cz = pz+dz;
        const key = `${cx},${cz}`;
        if (!chunks[key]) {
            buildProceduralCache(cx, cz);
            const meshes = buildChunk(cx, cz);
            chunks[key] = { meshes, dirty: false };
        } else if (chunks[key].dirty) {
            disposeChunk(key);
            chunks[key].meshes = buildChunk(cx, cz);
            chunks[key].dirty  = false;
        }
    }}
    // Nettoyage chunks lointains
    for (const key in chunks) {
        const [cx, cz] = key.split(',').map(Number);
        const dist = Math.max(Math.abs(cx-px), Math.abs(cz-pz));
        if (dist > RENDER_DIST + 1) {
            disposeChunk(key);
            delete chunks[key];
        }
    }
    document.getElementById('debug').textContent =
        `Chunks: ${Object.keys(chunks).length} | FPS: ${fps} | XYZ: ${Math.floor(camera.position.x)} ${Math.floor(camera.position.y)} ${Math.floor(camera.position.z)}`;
}

// ============================================================
// PHYSIQUE & COLLISIONS (CORRIG√â)
// ============================================================
function checkCollision(pos) {
    // V√©rification simple : le corps du joueur est un cylindre
    // On v√©rifie le point aux pieds et le point √† la t√™te
    const r = 0.3; // Rayon du joueur
    const x = pos.x;
    const y = pos.y;
    const z = pos.z;

    // Pieds (l√©g√®rement au-dessus du sol absolu pour √©viter le collage)
    if (getBlock(x, y - 1.5, z)) return true;
    // T√™te
    if (getBlock(x, y, z)) return true;
    
    // V√©rification des bords (murs) - 4 points cardinaux
    if (getBlock(x+r, y-1, z) || getBlock(x-r, y-1, z) || getBlock(x, y-1, z+r) || getBlock(x, y-1, z-r)) return true;
    if (getBlock(x+r, y, z) || getBlock(x-r, y, z) || getBlock(x, y, z+r) || getBlock(x, y, z-r)) return true;

    return false;
}

// Raycast pour placer/casser
function raycastDDA(maxDist = 6) {
    const origin = camera.position.clone();
    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
    let x = Math.floor(origin.x), y = Math.floor(origin.y), z = Math.floor(origin.z);
    const stepX = Math.sign(dir.x), stepY = Math.sign(dir.y), stepZ = Math.sign(dir.z);
    const deltaX = Math.abs(1/dir.x), deltaY = Math.abs(1/dir.y), deltaZ = Math.abs(1/dir.z);
    let dist = 0;
    // Initial side dists
    let sideX = (stepX > 0 ? x + 1 - origin.x : origin.x - x) * deltaX;
    let sideY = (stepY > 0 ? y + 1 - origin.y : origin.y - y) * deltaY;
    let sideZ = (stepZ > 0 ? z + 1 - origin.z : origin.z - z) * deltaZ;
    
    let face = null;

    for (let i = 0; i < maxDist * 2; i++) { // Safety limit
        if (getBlock(x, y, z)) return { x, y, z, face };
        
        if (sideX < sideY && sideX < sideZ) {
            sideX += deltaX; x += stepX; face = {x:-stepX, y:0, z:0};
        } else if (sideY < sideZ) {
            sideY += deltaY; y += stepY; face = {x:0, y:-stepY, z:0};
        } else {
            sideZ += deltaZ; z += stepZ; face = {x:0, y:0, z:-stepZ};
        }
        if (new THREE.Vector3(x+0.5, y+0.5, z+0.5).distanceTo(origin) > maxDist) break;
    }
    return null;
}

function swingArm() {
    if(!armMesh) return;
    const initialRot = armMesh.rotation.x;
    let t = 0;
    const animateSwing = () => {
        t += 0.2;
        armMesh.rotation.x = initialRot - Math.sin(t) * 0.5;
        if (t < Math.PI) requestAnimationFrame(animateSwing);
        else armMesh.rotation.x = initialRot;
    };
    animateSwing();
}

// ============================================================
// LOGIQUE PRINCIPALE
// ============================================================
function saveWorld() {
    savedWorld = { mods: { ...playerMods }, pos: camera.position.clone(), time: new Date() };
    document.getElementById('save-status').textContent = "‚úÖ Sauvegard√© !";
}
function loadWorld() {
    if (!savedWorld) return;
    playerMods = { ...savedWorld.mods };
    camera.position.copy(savedWorld.pos);
    reloadAllChunks();
    document.getElementById('save-status').textContent = "üìÇ Charg√© !";
}
function newWorld() {
    if (confirm("Reset ?")) { playerMods={}; proceduralCache={}; reloadAllChunks(); camera.position.set(0,30,0); }
}
function reloadAllChunks() {
    for (const k in chunks) disposeChunk(k);
    for (const k in chunks) delete chunks[k];
    proceduralCache = {};
}

function setupInputs() {
    document.addEventListener('keydown', e => {
        switch(e.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': if(canJump) { velocity.y = 0.18; canJump = false; } break;
            case 'ShiftLeft': isSprinting = true; break;
            case 'KeyC': {
                swingArm();
                const h = raycastDDA();
                if(h) setBlock(h.x, h.y, h.z, null);
                break;
            }
            case 'KeyV': {
                swingArm();
                const h = raycastDDA();
                if(h && h.face) {
                    const nx=h.x+h.face.x, ny=h.y+h.face.y, nz=h.z+h.face.z;
                    // Anti-coincement : ne pas poser sur soi-m√™me
                    const p = camera.position;
                    if (Math.abs(nx - p.x) < 0.8 && Math.abs(ny - (p.y-1)) < 1.8 && Math.abs(nz - p.z) < 0.8) return;
                    setBlock(nx, ny, nz, PLACE_BLOCKS[activeSlot]);
                }
                break;
            }
            default: 
                if (e.key >= '1' && e.key <= '8') {
                    activeSlot = parseInt(e.key)-1;
                    document.querySelectorAll('.hotslot').forEach((d,i)=>d.classList.toggle('active', i===activeSlot));
                }
        }
    });
    document.addEventListener('keyup', e => {
        switch(e.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyD': moveRight = false; break;
            case 'ShiftLeft': isSprinting = false; break;
        }
    });
    document.addEventListener('mousedown', () => controls.lock());
    document.addEventListener('wheel', e => {
        activeSlot = (activeSlot + Math.sign(e.deltaY) + 8) % 8;
        document.querySelectorAll('.hotslot').forEach((d,i)=>d.classList.toggle('active', i===activeSlot));
    });
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, (RENDER_DIST+1)*CHUNK_SIZE);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 30, 0);

    // Bras
    armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 1.2), new THREE.MeshLambertMaterial({ color: 0xeebb99 }));
    armMesh.position.set(0.4, -0.4, -0.6);
    armMesh.rotation.set(0.2, -0.1, 0);
    camera.add(armMesh);

    scene.add(new THREE.AmbientLight(0x888888));
    const sun = new THREE.DirectionalLight(0xffffff, 0.7);
    sun.position.set(50,100,50);
    scene.add(sun);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    loadMaterials();
    setupInputs();

    // Boutons UI
    document.getElementById('btn-save').onclick = saveWorld;
    document.getElementById('btn-load').onclick = loadWorld;
    document.getElementById('btn-new').onclick = newWorld;
    document.getElementById('btn-play').onclick = () => controls.lock();
    
    controls.addEventListener('lock', () => document.getElementById('overlay').classList.add('hidden'));
    controls.addEventListener('unlock', () => document.getElementById('overlay').classList.remove('hidden'));
    
    // Sliders
    document.getElementById('slider-dist').oninput = function() {
        RENDER_DIST = parseInt(this.value);
        document.getElementById('dist-val').textContent = RENDER_DIST;
        scene.fog.far = (RENDER_DIST+1)*CHUNK_SIZE;
    };
    
    animate();
}

function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    frameCount++;
    if (now - lastFpsTime >= 1000) { fps=frameCount; frameCount=0; lastFpsTime=now; }

    if (controls.isLocked) {
        // --- 1. Calculs Input ---
        const speed = isSprinting ? 0.25 : 0.12;
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const vForward = direction.z * speed;
        const vRight   = direction.x * speed;

        // --- 2. Physique & Collisions (AABB simple) ---
        // On bouge un axe √† la fois pour glisser contre les murs
        
        // --- Axe X ---
        controls.moveRight(vRight);
        if (checkCollision(camera.position)) {
            controls.moveRight(-vRight); // Annuler mouvement si collision
        }

        // --- Axe Z ---
        controls.moveForward(vForward);
        if (checkCollision(camera.position)) {
            controls.moveForward(-vForward); // Annuler mouvement si collision
        }

        // --- Axe Y (Gravit√©) ---
        velocity.y -= 0.01; // Gravit√© constante
        camera.position.y += velocity.y;
        
        // Collision Sol/Plafond
        // On v√©rifie sp√©cifiquement les pieds
        if (getBlock(camera.position.x, camera.position.y - 1.6, camera.position.z)) {
            // Collision Sol
            if (velocity.y < 0) {
                velocity.y = 0;
                canJump = true;
                // Caler sur le bloc entier
                camera.position.y = Math.floor(camera.position.y - 1.6) + 1 + 1.6001;
            }
        } 
        // Collision T√™te (Plafond)
        else if (getBlock(camera.position.x, camera.position.y + 0.1, camera.position.z)) {
            if (velocity.y > 0) velocity.y = 0;
        }

        // Animation bras
        if (moveForward||moveBackward||moveLeft||moveRight) {
            armMesh.position.y = -0.4 + Math.sin(now * 0.015) * 0.02;
        }

        if (now - lastChunkTick > 200) { updateChunks(); lastChunkTick = now; }
    }
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

init();
</script>
</body>
</html>