<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Astro Dodge</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { 
    margin:0; 
    background: #0a0e27; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    height:100vh; 
    color:#fff; 
    font-family:sans-serif; 
    overflow:hidden; 
}
canvas { 
    background: #020510; 
    border:3px solid #00d9ff; 
    box-shadow: 0 0 40px rgba(0,217,255,0.8); 
    border-radius: 8px; 
    max-width: calc((100vh - 6px) * 420 / 640);
    max-height: calc((100vw - 6px) * 640 / 420);
    width: 100%;
    height: 100%;
    object-fit: contain;
    position: absolute; 
}

:fullscreen canvas {
    border: none;
    box-shadow: none;
}
:-webkit-full-screen canvas { border: none; box-shadow: none; }
:-moz-full-screen canvas { border: none; box-shadow: none; }
:-ms-fullscreen canvas { border: none; box-shadow: none; }
</style>
</head>
<body>
<canvas id="game"></canvas> 
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

// =================================================================
// --- SYST√àME DE SONS ---
// =================================================================
const AudioSystem = {
    context: null,
    sounds: {},
    masterVolume: 0.3,
    
    init() {
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            this.generateSounds();
        } catch(e) {
            console.warn("Audio non disponible");
        }
    },
    
    generateSounds() {
        // Son de bouton hover
        this.sounds.buttonHover = this.createTone(800, 0.05, 0.1, 'sine');
        
        // Son de clic
        this.sounds.buttonClick = this.createTone(600, 0.1, 0.15, 'square');
        
        // Son de fus√©e (moteur continu)
        this.sounds.rocket = this.createNoise(0.3, 'brown');
        
        // Son de pi√®ce collect√©e
        this.sounds.coin = this.createSequence([
            {freq: 800, duration: 0.05},
            {freq: 1000, duration: 0.05},
            {freq: 1200, duration: 0.1}
        ]);
        
        // Son de crash
        this.sounds.crash = this.createExplosion();
        
        // Son de niveau suivant
        this.sounds.levelUp = this.createSequence([
            {freq: 400, duration: 0.1},
            {freq: 600, duration: 0.1},
            {freq: 800, duration: 0.15}
        ]);
        
        // Son de d√©g√¢ts
        this.sounds.hit = this.createTone(200, 0.2, 0.3, 'sawtooth');
        
        // Son de fr√¥lement (ajout√©)
        this.sounds.nearMiss = this.createTone(1500, 0.03, 0.08, 'triangle');
    },
    
    createTone(freq, duration, volume, type = 'sine') {
        return () => {
            if (!this.context) return;
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = volume * this.masterVolume;
            
            osc.connect(gain);
            gain.connect(this.context.destination);
            
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
            osc.stop(this.context.currentTime + duration);
        };
    },
    
    createNoise(volume, type = 'white') {
        return () => {
            if (!this.context) return;
            const bufferSize = this.context.sampleRate * 0.5;
            const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const source = this.context.createBufferSource();
            const gain = this.context.createGain();
            const filter = this.context.createBiquadFilter();
            
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            
            source.buffer = buffer;
            gain.gain.value = volume * this.masterVolume;
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(this.context.destination);
            
            source.start();
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
            source.stop(this.context.currentTime + 0.5);
        };
    },
    
    createSequence(notes) {
        return () => {
            if (!this.context) return;
            let time = this.context.currentTime;
            
            notes.forEach(note => {
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = note.freq;
                gain.gain.value = 0.2 * this.masterVolume;
                
                osc.connect(gain);
                gain.connect(this.context.destination);
                
                osc.start(time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + note.duration);
                osc.stop(time + note.duration);
                
                time += note.duration;
            });
        };
    },
    
    createExplosion() {
        return () => {
            if (!this.context) return;
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.value = 100;
            gain.gain.value = 0.5 * this.masterVolume;
            
            osc.connect(gain);
            gain.connect(this.context.destination);
            
            osc.start();
            osc.frequency.exponentialRampToValueAtTime(20, this.context.currentTime + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
            osc.stop(this.context.currentTime + 0.5);
        };
    },
    
    play(soundName) {
        if (this.sounds[soundName]) {
            this.sounds[soundName]();
        }
    }
};

// Initialisation du syst√®me audio
AudioSystem.init();

// =================================================================
// --- CONFIGURATION API ---
// =================================================================
const API_BASE_URL = "https://project-3-api-2bgb.onrender.com/astro"; 

const GAME_WIDTH = 420;
const GAME_HEIGHT = 640;

let scaleFactor = 1;
let currentHoverButton = null; 
let lastHoveredButton = null;

function requestFullScreen(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen().catch(err => console.error("Plein √©cran bloqu√©:", err));
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen().catch(err => console.error("Plein √©cran bloqu√©:", err));
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen().catch(err => console.error("Plein √©cran bloqu√©:", err));
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen().catch(err => console.error("Plein √©cran bloqu√©:", err));
    }
}

window.onload = function() {
    resizeCanvas();
};

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    scaleFactor = canvas.width / GAME_WIDTH;
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    ctx.scale(scaleFactor, scaleFactor);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

let mouseX = 0, mouseY = 0, isMouseDown = false;

function getScaledMouseCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const virtualX = (clientX - rect.left) / scaleFactor;
    const virtualY = (clientY - rect.top) / scaleFactor;
    return { x: virtualX, y: virtualY };
}

canvas.addEventListener("mousemove", e => { 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mousedown", e => { 
    isMouseDown = true; 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mouseup", () => isMouseDown = false);
canvas.addEventListener("touchstart", e => {
    isMouseDown = true;
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchmove", e => {
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchend", () => isMouseDown = false);

function mouseInRect(x,y,w,h){ return mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h; }

const STATE={MENU:0,PLAY:1,GAMEOVER:2,SHOP:3, TAKEOFF:4, LANDING:5, LEADERBOARD:6, LOADING: 7, START_SCREEN: 8}; 
let state=STATE.LOADING; 

let transition = { active: false, alpha: 0, nextState: null, callback: null };

let username = localStorage.getItem("username") || "Invit√©"; 
let score=0, bestScore=0, credits=0; 
let time=0, spawnTimer=0, asteroids=[], stars=[], coins=[], keys={}, explosion=null, flashAlpha=0;
let coinFlashAlpha = 0, floatingTexts = [], shopScroll=0;
let player={x:210,y:560,r:18,type:0,life:1, invulnerable:0, trail:[], angle:0};
let leaderboardData = []; 
let loadingShip = { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, angle: 0, r: 20, particles: [] }; 
let loadingProgress = 0;
let startButtonAnim = { scale: 1, alpha: 0, hover: false, pulse: 0 }; 

let menuParticles = [];
for(let i=0; i<25; i++) menuParticles.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, l: Math.random()*30+10, s: Math.random()*8+4});

let nebulas = [];
function initNebulas() {
    nebulas = [];
    const colors = ["rgba(100, 0, 255, 0.08)", "rgba(0, 150, 255, 0.08)", "rgba(255, 0, 150, 0.08)"];
    for(let i=0; i<3; i++) nebulas.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, r: 150+Math.random()*150, color: colors[i], speed: 0.15+Math.random()*0.1});
}
initNebulas();

let launchProgress = 0, earthY = 0, deathShockwave = { active: false, r: 0, alpha: 0, x: 0, y: 0 }, timeScale = 1, glitchTimer = 0;
let currentLevel = 1, levelAnimTimer = 0, colorIndex = 0;
const levelColors = ["#00d9ff", "#ff00ea", "#00ff88", "#ff3300", "#ffcc00", "#9d00ff"];

const ships=[
{name:"Standard", cost:0, speed:5, unlocked:true, color:"#0288d1", cockpit:"#81d4fa", flame:"#ff7043", bonus:"Aucun", desc:"Stable et √©quilibr√©."},
{name:"Rapide", cost:1000, speed:8, unlocked:false, color:"#d32f2f", cockpit:"#ff8a80", flame:"#ffeb3b", bonus:"Vitesse +2", desc:"Esquives √©clairs."},
{name:"Double Pi√®ces", cost:1500, speed:5, unlocked:false, color:"#388e3c", cockpit:"#a5d6a7", flame:"#ff9800", bonus:"Pi√®ces x2", desc:"Richesse instantan√©e."},
{name:"Score Boost", cost:2000, speed:5, unlocked:false, color:"#7b1fa2", cockpit:"#ce93d8", flame:"#f48fb1", bonus:"Score x2", desc:"Progression rapide."},
{name:"magnet", cost:2500, speed:5, unlocked:false, color:"#ffde21", cockpit:"#ce93d8", flame:"#c2185b", bonus:"Aim Magn√©tique", desc:"Attire l'or √† distance."},
{name:"Titan", cost:5000, speed:5, unlocked:false, color:"#ff6f00", cockpit:"#ffcc80", flame:"#ff1744", bonus:"Vie Suppl√©mentaire", desc:"Blindage renforc√©."}
];

function clearOldLocalStorage() {
    ["astro_best", "astro_credits", "astro_unlocked_ships"].forEach(key => {
        localStorage.removeItem(key);
    });
}
clearOldLocalStorage(); 

function changeState(newState, callback = null) {
    if (transition.active) return;
    transition.active = true; transition.alpha = 0; transition.nextState = newState; transition.callback = callback;
}

function updateTransition() {
    if (!transition.active) return;
    if (transition.nextState !== null) {
        transition.alpha += 0.05; 
        if (transition.alpha >= 1) { 
            state = transition.nextState; 
            transition.nextState = null; 
            if (transition.callback) transition.callback(); 
        }
    } else {
        transition.alpha -= 0.05; 
        if (transition.alpha <= 0) { 
            transition.alpha = 0; 
            transition.active = false; 
        }
    }
}

async function loadGameData() {
    // Simulation de chargement avec progression
    for (let i = 0; i <= 100; i += 2) {
        loadingProgress = i;
        await new Promise(resolve => setTimeout(resolve, 20));
    }
    
    try {
        const response = await fetch(`${API_BASE_URL}/load_data/${username}`);
        const result = await response.json();

        if (result.status === "success" || result.status === "not_found") {
            const data = result.data;
            bestScore = Number(data.PR_Score) || 0;
            credits = Number(data.Coins) || 0;
            const unlockedCarsString = data.Voiture || "Standard"; 
            const unlockedCarsArray = unlockedCarsString.split(',');
            let selectedShipName = ships[player.type].name; 
            let firstUnlockedIndex = 0;
            
            ships.forEach((ship, i) => {
                ship.unlocked = unlockedCarsArray.includes(ship.name);
                if(i === 0) ship.unlocked = true; 
                if (ship.unlocked && firstUnlockedIndex === 0) {
                    firstUnlockedIndex = i;
                }
            });

            const savedShipIndex = ships.findIndex(s => s.name === selectedShipName && s.unlocked);
            player.type = savedShipIndex !== -1 ? savedShipIndex : firstUnlockedIndex;

            state = STATE.START_SCREEN; 
            transition.active = false;
            transition.nextState = null;
        } else {
            console.error("Erreur de chargement des donn√©es:", result.message);
            state = STATE.START_SCREEN; 
            transition.active = false;
        }
    } catch (e) {
        console.error("Erreur de connexion API au chargement:", e);
        state = STATE.START_SCREEN; 
        transition.active = false;
    }
}

async function saveGameData(newScore = null) {
    if (username === "Invit√©") return; 

    const unlockedCarsNames = ships.filter(s => s.unlocked).map(s => s.name).join(',');

    const dataToSave = {
        username: username,
        Coins: credits, 
        Voiture: unlockedCarsNames 
    };
    
    if (newScore !== null) {
        dataToSave.PR_Score = Math.floor(newScore);
    }

    try {
        const response = await fetch(`${API_BASE_URL}/save_data`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(dataToSave)
        });
        const result = await response.json();
    } catch (e) {
        console.error("Erreur de connexion API √† la sauvegarde:", e);
    }
}

async function loadLeaderboard() {
    try {
        const response = await fetch(`${API_BASE_URL}/leaderboard`);
        const result = await response.json();
        
        if (result.status === "success") {
            leaderboardData = result.leaderboard.map(e => ({
                name: (e.username === username ? "Vous" : e.username), 
                score: e.PR_Score
            })).sort((a, b) => b.score - a.score).slice(0, 5); 
            
            if (!leaderboardData.some(e => e.name === "Vous")) {
                leaderboardData.push({ name: "Vous", score: bestScore });
            }
        } 
    } catch (e) {
        console.error("Erreur de connexion API au classement:", e);
    }
}

canvas.addEventListener("click", e=>{
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    
    if (transition.active) return; 

    if(state === STATE.START_SCREEN) {
        if(mouseInRect(110, 480, 200, 50)) {
            AudioSystem.play('buttonClick');
            requestFullScreen(document.documentElement); 
            changeState(STATE.MENU);
        }
    }
    
    else if(state===STATE.MENU){
      if(mouseInRect(110, 240, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.TAKEOFF, startLaunchAnimation); }
      if(mouseInRect(110, 310, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.SHOP); }
      if(mouseInRect(110, 380, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.LEADERBOARD, loadLeaderboard); }
      if(mouseInRect(110, 450, 200, 50)) { AudioSystem.play('buttonClick'); window.location.href = "../../menu.html"; }
    } else if(state===STATE.SHOP || state===STATE.LEADERBOARD){
      if(mouseInRect(110, 540, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.MENU); }
      if(state===STATE.SHOP){
        ships.forEach((s,i)=>{
          const cardY=140+i*160 - shopScroll;
          if(mouseInRect(40, cardY, 340, 140)){
            if(!s.unlocked && credits>=s.cost){ 
              AudioSystem.play('coin');
              credits-=s.cost; 
              s.unlocked=true; 
              player.type = i;
              saveGameData(); 
            } else if(s.unlocked) {
                AudioSystem.play('buttonClick');
                player.type=i;
                saveGameData(); 
            }
          }
        });
      }
    } else if(state===STATE.GAMEOVER && flashAlpha <= 0.1) {
      AudioSystem.play('buttonClick');
      asteroids = []; coins = []; explosion = null; launchProgress = 1; earthY = 800; player.angle = Math.PI; state = STATE.LANDING;
    }
});

document.addEventListener("keydown", e=>{ 
    keys[e.key]=true; 
    if(e.key==="Escape" && (state===STATE.PLAY || state===STATE.SHOP || state===STATE.LEADERBOARD)) {
        AudioSystem.play('buttonClick');
        changeState(STATE.MENU); 
    }
});
document.addEventListener("keyup", e=>keys[e.key]=false);
canvas.addEventListener("wheel", e=>{ if(state===STATE.SHOP) shopScroll = Math.max(0, Math.min(shopScroll + e.deltaY, (ships.length-1)*160)); });

function initStars(){ stars=[]; for(let i=0;i<80;i++) stars.push({x:Math.random()*GAME_WIDTH, y:Math.random()*GAME_HEIGHT, s:Math.random()*2.5+0.5, speed: Math.random()*0.3+0.1, twinkle: Math.random()*Math.PI*2}); }
initStars();

function startLaunchAnimation() {
    AudioSystem.play('rocket');
    asteroids=[]; coins=[]; score=0; time=0; spawnTimer=0; explosion=null; flashAlpha=0; floatingTexts=[]; deathShockwave.active = false; glitchTimer = 0;
    timeScale = 1; launchProgress = 0; earthY = 500; currentLevel = 1; colorIndex = 0;
    player.x = 210; player.y = 520; player.trail = []; player.angle = 0;
    player.life=ships[player.type].bonus==="Vie Suppl√©mentaire" ? 2 : 1; state = STATE.TAKEOFF;
}

function update(){
    updateTransition();
    canvas.style.cursor = "default";
    if(flashAlpha > 0) flashAlpha -= 0.05;
    if(coinFlashAlpha > 0) coinFlashAlpha -= 0.1;
    if(glitchTimer > 0) glitchTimer--;

    if(state === STATE.LOADING) {
        loadingShip.angle += 0.08;
        
        // Particules du vaisseau en chargement
        if(time % 3 === 0) {
            loadingShip.particles.push({
                x: loadingShip.x + (Math.random()-0.5)*15,
                y: loadingShip.y + 20,
                r: 2 + Math.random()*3,
                alpha: 0.8,
                speed: 2 + Math.random()*2
            });
        }
        loadingShip.particles.forEach((p, i) => {
            p.y += p.speed;
            p.alpha -= 0.02;
            if(p.alpha <= 0) loadingShip.particles.splice(i, 1);
        });
        
    } else if (state === STATE.START_SCREEN) {
        const isHovering = mouseInRect(110, 480, 200, 50);
        
        if (isHovering) {
            startButtonAnim.scale += (1.08 - startButtonAnim.scale) * 0.15;
            if (!startButtonAnim.hover) {
                AudioSystem.play('buttonHover');
                startButtonAnim.hover = true;
            }
        } else {
            startButtonAnim.scale += (1.0 - startButtonAnim.scale) * 0.15;
            startButtonAnim.hover = false;
        }
        startButtonAnim.alpha += (1.0 - startButtonAnim.alpha) * 0.05;
        startButtonAnim.pulse += 0.05;
    }

    if(state === STATE.MENU) {
        menuParticles.forEach(p => { p.y += p.s; if(p.y > GAME_HEIGHT) { p.y = -20; p.x = Math.random()*GAME_WIDTH; } });
        
        // D√©tection hover pour sons
        const buttons = [
            {x: 110, y: 240, w: 200, h: 50, id: 'play'},
            {x: 110, y: 310, w: 200, h: 50, id: 'shop'},
            {x: 110, y: 380, w: 200, h: 50, id: 'leader'},
            {x: 110, y: 450, w: 200, h: 50, id: 'quit'}
        ];
        
        let hovering = null;
        buttons.forEach(btn => {
            if(mouseInRect(btn.x, btn.y, btn.w, btn.h)) {
                hovering = btn.id;
            }
        });
        
        if(hovering && hovering !== lastHoveredButton) {
            AudioSystem.play('buttonHover');
            lastHoveredButton = hovering;
        } else if(!hovering) {
            lastHoveredButton = null;
        }
    }

    floatingTexts.forEach((t, i) => { t.y -= 2; t.alpha -= 0.02; if(t.alpha <= 0) floatingTexts.splice(i, 1); });

    nebulas.forEach(n => { n.y += n.speed * (state === STATE.GAMEOVER ? timeScale : 1); if(n.y - n.r > GAME_HEIGHT) { n.y = -n.r; n.x = Math.random() * GAME_WIDTH; } });

    if(state === STATE.TAKEOFF) { launchProgress += 0.005; earthY += 4; player.y -= 0.5; if(launchProgress >= 1) { AudioSystem.play('rocket'); state = STATE.PLAY; } }
    if(state === STATE.LANDING) { launchProgress -= 0.01; earthY -= 5; player.y += 2; if(earthY <= 500) changeState(STATE.MENU); }

    if(state!==STATE.PLAY && state!==STATE.GAMEOVER && state!==STATE.TAKEOFF && state!==STATE.LANDING) return;
    
    let currentSpeed = (state === STATE.GAMEOVER) ? timeScale : 1;
    if(state === STATE.GAMEOVER && timeScale > 0) timeScale -= 0.02;

    time++; 
    if(player.invulnerable > 0) player.invulnerable--;
    const sD=ships[player.type];

    if(state === STATE.PLAY || state === STATE.TAKEOFF || state === STATE.LANDING) {
        let trailY = state === STATE.LANDING ? player.y - 15 : player.y + 15;
        if(time % 2 === 0) player.trail.push({x: player.x + (Math.random()-0.5)*10, y: trailY, r: 4 + Math.random()*4, alpha: 0.6});
    }
    player.trail.forEach((p, i) => { p.y += (state === STATE.LANDING ? -3 : 3) * currentSpeed; p.alpha -= 0.02; p.r *= 0.98; if(p.alpha <= 0) player.trail.splice(i, 1); });

    if(state === STATE.PLAY) {
        let nextLvl = Math.floor(score/500) + 1;
        if(nextLvl > currentLevel) { 
            currentLevel = nextLvl; levelAnimTimer = 100; colorIndex = (currentLevel - 1) % levelColors.length; flashAlpha = 0.3; 
            credits += 50;
            AudioSystem.play('levelUp');
            saveGameData(); 
        }
        if(levelAnimTimer > 0) levelAnimTimer--;

        score += (sD.bonus==="Score x2" ? 1.1 : 0.55);
        spawnTimer++;
        if(spawnTimer>=Math.max(10, 40 - Math.floor(score/150))){ spawnAsteroid(); spawnTimer=0; }
        
        // --- LOGIQUE DE ROTATION DU VAISSEAU (MODIFI√âE) ---
        let targetAngle = 0; 

        if(keys.ArrowLeft) { 
            player.x-=sD.speed; 
            targetAngle = -0.8; // Rotation TR√àS augment√©e
        }
        if(keys.ArrowRight) { 
            player.x+=sD.speed; 
            targetAngle = 0.8; // Rotation TR√àS augment√©e
        }
        
        if(keys.ArrowUp) player.y-=sD.speed; 
        if(keys.ArrowDown) player.y+=sD.speed;

        // Lissage de l'angle (augment√© √† 0.2 pour une rotation plus rapide)
        player.angle += (targetAngle - player.angle) * 0.2;
        // --- FIN LOGIQUE DE ROTATION ---
        
        player.x=Math.max(player.r, Math.min(GAME_WIDTH-player.r, player.x));
        player.y=Math.max(player.r, Math.min(GAME_HEIGHT-player.r, player.y));
        
        asteroids.forEach(a=>{
            a.y+=a.speed; a.rot+=a.rotSpeed;
            const dist = Math.hypot(player.x-a.x,player.y-a.y);
            const collisionDist = player.r + a.r;
            const nearMissDist = collisionDist + 15; 

            // 1. D√©tection de collision
            if(dist < collisionDist && player.invulnerable===0){
                if(player.life>1){ 
                    player.life--; player.invulnerable=60; flashAlpha=0.4; asteroids=[];
                    AudioSystem.play('hit');
                } 
                else {
                    state = STATE.GAMEOVER; flashAlpha = 1; timeScale = 1;
                    AudioSystem.play('crash');
                    
                    if(Math.floor(score)>bestScore){ 
                        bestScore=Math.floor(score); 
                    }
                    saveGameData(score); 
                }
            } 
            // 2. D√©tection de fr√¥lement (Near Miss)
            else if (dist < nearMissDist && !a.nearMissed) {
                if (player.invulnerable === 0) {
                    a.nearMissed = true;
                    const bonusScore = 50;
                    score += bonusScore;
                    AudioSystem.play('nearMiss');
                    floatingTexts.push({x: player.x, y: player.y - player.r - 10, text: `+${bonusScore} FR√îLEMENT!`, alpha: 1, color: "#00ff88"}); 
                }
            }
        });

        if(time%350===0) spawnCoin();
    }

    asteroids=asteroids.filter(a=>a.y<GAME_HEIGHT+50);
    coins.forEach(c=>{
        c.y+=2.5 * currentSpeed;
        if(sD.bonus==="Aim Magn√©tique" && Math.hypot(player.x-c.x,player.y-c.y)<220){ c.x+=(player.x-c.x)*0.07; c.y+=(player.y-c.y)*0.07; }
        if(Math.hypot(player.x-c.x,player.y-c.y)<player.r+c.r){ 
            const val = 50*(sD.bonus==="Pi√®ces x2"?2:1); 
            credits+=val;
            AudioSystem.play('coin');
            saveGameData(); 
            c.collected=true; coinFlashAlpha = 0.3; 
            floatingTexts.push({x: c.x, y: c.y, text: `+${val} üí∞`, alpha: 1, color: "#ffd700"}); 
        }
    });
    coins=coins.filter(c=>c.y<GAME_HEIGHT && !c.collected);
}

function spawnAsteroid(){ 
    const r=16+Math.random()*28; 
    asteroids.push({
        x:r + Math.random()*(GAME_WIDTH-2*r), 
        y:-r-50, r, 
        speed:1.8 + Math.random()*1.5 + (score/800), 
        rot:Math.random()*Math.PI*2, 
        rotSpeed:(Math.random()-0.5)*0.05, 
        pts:Array.from({length:7}, ()=>0.6+Math.random()*0.8),
        nearMissed: false 
    }); 
}
function spawnCoin(){ coins.push({x:25+Math.random()*370,y:-10,r:8,collected:false}); }

function draw(){
    const curCol = (state === STATE.MENU || state === STATE.SHOP || state === STATE.LEADERBOARD || state === STATE.LOADING || state === STATE.START_SCREEN) ? "#00d9ff" : levelColors[colorIndex];
    ctx.fillStyle = "#020510"; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);

    nebulas.forEach(n => { let g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r); g.addColorStop(0, n.color); g.addColorStop(1, "transparent"); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI*2); ctx.fill(); });

    if(state === STATE.MENU || state === STATE.START_SCREEN){
        ctx.strokeStyle = "rgba(0, 217, 255, 0.15)"; ctx.lineWidth = 2;
        menuParticles.forEach(p => { ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + p.l); ctx.stroke(); });
    }

    stars.forEach(s=>{ ctx.fillStyle=`rgba(255,255,255,${(0.3+Math.sin(time*0.05+s.twinkle)*0.4)})`; ctx.fillRect(s.x,s.y,s.s,s.s); if(state === STATE.PLAY || state === STATE.GAMEOVER || state === STATE.TAKEOFF || state === STATE.LANDING) { let starDir = state === STATE.LANDING ? -s.speed : s.speed; s.y+=starDir * (state===STATE.GAMEOVER?timeScale:1); if(s.y>GAME_HEIGHT) s.y=0; if(s.y<0) s.y=GAME_HEIGHT; } });

    if(state === STATE.TAKEOFF || state === STATE.LANDING) { ctx.fillStyle = "#2e7d32"; ctx.beginPath(); ctx.arc(210, earthY + 400, 500, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#1565c0"; ctx.beginPath(); ctx.arc(210, earthY + 420, 480, 0, Math.PI*2); ctx.fill(); }

    if(state === STATE.PLAY || state === STATE.GAMEOVER || state === STATE.TAKEOFF || state === STATE.LANDING) {
        player.trail.forEach(p => { ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); });
        asteroids.forEach(a=>{ ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.rot); ctx.shadowBlur=12; ctx.shadowColor=curCol; const g=ctx.createRadialGradient(0,0,0,0,0,a.r); g.addColorStop(0,"#fff"); g.addColorStop(0.4, curCol); g.addColorStop(1,"#111"); ctx.fillStyle=g; ctx.beginPath(); a.pts.forEach((p,i)=>{ const ang=i/a.pts.length*Math.PI*2; ctx.lineTo(Math.cos(ang)*a.r*p, Math.sin(ang)*a.r*p); }); ctx.closePath(); ctx.fill(); ctx.restore(); });
        coins.forEach(c=>{ ctx.shadowBlur=15; ctx.shadowColor="#ffd700"; ctx.fillStyle="#ffd700"; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; });
    }

    const sD=ships[player.type];
    if(state===STATE.PLAY || state===STATE.TAKEOFF || state===STATE.LANDING || (state===STATE.GAMEOVER && timeScale > 0.5)){ 
        ctx.save(); 
        ctx.translate(player.x,player.y); 
        ctx.rotate(player.angle); 
        if(player.invulnerable>0 && Math.floor(time/5)%2===0) ctx.globalAlpha=0.3; 
        ctx.fillStyle=sD.flame; 
        ctx.beginPath(); ctx.moveTo(-8,15); ctx.lineTo(0,20+Math.sin(time*0.5)*8); ctx.lineTo(8,15); ctx.fill(); 
        ctx.shadowBlur=20; ctx.shadowColor=sD.color; 
        ctx.fillStyle=sD.color; 
        ctx.beginPath(); 
        ctx.moveTo(0,-22); ctx.lineTo(16,18); ctx.lineTo(0,10); ctx.lineTo(-16,18); ctx.fill(); 
        ctx.fillStyle=sD.cockpit; 
        ctx.beginPath(); ctx.arc(0,-4,6,0,Math.PI*2); ctx.fill(); 
        ctx.restore(); 
    }

    if(state === STATE.START_SCREEN) {
        ctx.save(); ctx.globalAlpha = startButtonAnim.alpha;
        const bounce = Math.sin(time * 0.04) * 8;
        ctx.translate(210, 150 + bounce); 
        ctx.shadowBlur = 20 + Math.sin(time*0.1)*10; ctx.shadowColor = "#00d9ff"; 
        ctx.fillStyle = "#fff"; ctx.font = "bold 52px sans-serif"; ctx.textAlign = "center"; 
        ctx.fillText("ASTRO DODGE", 0, 0); 
        ctx.font = "bold 18px sans-serif"; ctx.fillStyle = "rgba(0, 217, 255, 0.8)"; 
        ctx.fillText(`Donn√©es charg√©es : ${username}`, 0, 45); 
        ctx.restore();
        
        // Effet de pulsation lumineux autour du bouton (maintenant arrondi)
        const pulseIntensity = Math.sin(startButtonAnim.pulse) * 0.3 + 0.7;
        ctx.save();
        ctx.globalAlpha = startButtonAnim.alpha * 0.3 * pulseIntensity;
        ctx.shadowBlur = 40;
        ctx.shadowColor = curCol;
        ctx.strokeStyle = curCol;
        ctx.lineWidth = 3;
        drawRoundedRect(110, 480, 200, 50, 10, false, true); 
        ctx.restore();
        
        drawBtn("COMMENCER", 210, 480, 200, 50, curCol, startButtonAnim.scale, startButtonAnim.alpha);
    
    } else if(state===STATE.MENU){
        
        // --- Hotbar du Menu Principal (Meilleur Score et Cr√©dits) ---
        const barW = 300, barH = 30, barR = 8;
        const barX = (GAME_WIDTH - barW) / 2;
        const barY = 5;
        const textY = barY + barH/2 + 5; 
        
        // 1. Dessin du fond sombre semi-transparent
        ctx.fillStyle="rgba(0, 0, 0, 0.7)"; 
        drawRoundedRect(barX, barY, barW, barH, barR, true, false); 

        // 2. Dessin du contour n√©on (utilise curCol)
        ctx.strokeStyle = curCol; 
        ctx.lineWidth = 2;
        drawRoundedRect(barX, barY, barW, barH, barR, false, true, curCol, 15); 
        
        // 3. Dessin des textes
        ctx.fillStyle="#fff"; ctx.font="bold 14px sans-serif"; 
        
        // Meilleur Score (Left)
        ctx.textAlign="left"; 
        ctx.fillText(`üèÜ ${bestScore}`, barX + 15, textY); 
        
        // Cr√©dits (Right)
        ctx.textAlign="right"; 
        ctx.fillText(`üí∞ ${credits}`, barX + barW - 15, textY); 
        // --- Fin Hotbar Menu ---
        
        const bounce = Math.sin(time * 0.04) * 8;
        ctx.save(); ctx.translate(210, 150 + bounce); ctx.shadowBlur = 20 + Math.sin(time*0.1)*10; ctx.shadowColor = "#00d9ff"; ctx.fillStyle = "#fff"; ctx.font = "bold 52px sans-serif"; ctx.textAlign = "center"; ctx.fillText("ASTRO DODGE", 0, 0); ctx.font = "bold 12px sans-serif"; ctx.fillStyle = "rgba(0, 217, 255, 0.8)"; ctx.fillText(`Bienvenue, ${username}`, 0, 25); ctx.restore();
        drawBtn("‚ñ∂ JOUER", 210, 240, 200, 50, curCol);
        drawBtn("üõí SHOP", 210, 310, 200, 50, curCol);
        drawBtn("üèÜ CLASSEMENT", 210, 380, 200, 50, curCol);
        drawBtn("‚úñ QUITTER", 210, 450, 200, 50, "#ff3300");
    } else if(state===STATE.LEADERBOARD){
        ctx.fillStyle="#fff"; ctx.font="bold 30px sans-serif"; ctx.textAlign="center"; ctx.fillText("CLASSEMENT MONDIAL", 210, 80);
        leaderboardData.forEach((entry, i) => { const y = 160 + i * 60; const isPlayer = entry.name === "Vous"; ctx.fillStyle = isPlayer ? "rgba(0, 217, 255, 0.2)" : "rgba(255, 255, 255, 0.05)"; ctx.fillRect(40, y-35, 340, 50); ctx.fillStyle = isPlayer ? "#00d9ff" : "#fff"; ctx.textAlign = "left"; ctx.font = "bold 20px sans-serif"; ctx.fillText(`${i+1}. ${entry.name}`, 60, y); ctx.textAlign = "right"; ctx.fillText(`${entry.score}`, 360, y); });
        drawBtn("RETOUR", 210, 540, 200, 50, curCol);
    } else if(state===STATE.SHOP){
        
        ctx.fillStyle="#fff"; ctx.font="bold 30px sans-serif"; ctx.textAlign="center"; ctx.fillText("BOUTIQUE", 210, 75); 

        // Dessin des cartes (avec coins arrondis et ombre)
        ships.forEach((s,i)=>{ 
            const cardY=140+i*160 - shopScroll; 
            if(cardY > GAME_HEIGHT || cardY < -140) return; 
            const hover = mouseInRect(40, cardY, 340, 140); 
            
            // 1. Dessin du fond de carte arrondi avec ombre
            ctx.shadowBlur=hover?25:15; 
            ctx.shadowColor=player.type===i?"#fff":s.color; 
            ctx.fillStyle=hover?"#252545":"#1a1a2e"; 
            drawRoundedRect(40, cardY, 340, 140, 10, true, false); 
            ctx.shadowBlur=0; 
            
            // 2. Dessin du contenu
            ctx.fillStyle="#fff"; ctx.textAlign="left"; ctx.font="bold 18px sans-serif"; ctx.fillText(s.name, 60, cardY+35); 
            ctx.fillStyle=curCol; ctx.font="14px sans-serif"; ctx.fillText(s.bonus, 60, cardY+55); 
            ctx.fillStyle="#aaa"; wrapText(s.desc, 60, cardY+80, 240, 16); 
            ctx.fillStyle=s.unlocked?(player.type===i?"#00ff88":"#888"):"#ffd700"; 
            ctx.textAlign="right"; ctx.fillText(s.unlocked?(player.type===i?"√âQUIP√â":"D√âBLOQU√â"):s.cost+" üí∞", 360, cardY+35); 
        });

        drawBtn("RETOUR", 210, 540, 200, 50, curCol);
        
        // --- Affichage des Cr√©dits dans la Boutique (Hotbar style, DESSIN√â EN DERNIER pour √™tre au-dessus) ---
        const barX = 130; 
        const barY = 10;
        const barW = 160;
        const barH = 35;
        const barR = 8;
        const textY = barY + barH/2 + 5;
        
        // 1. Dessin du fond sombre semi-transparent
        ctx.fillStyle="rgba(0, 0, 0, 0.7)"; 
        drawRoundedRect(barX, barY, barW, barH, barR, true, false); 

        // 2. Dessin du contour n√©on
        ctx.strokeStyle = curCol; 
        ctx.lineWidth = 2;
        drawRoundedRect(barX, barY, barW, barH, barR, false, true, curCol, 15); 
        
        // 3. Dessin des √©l√©ments
        ctx.fillStyle="#ffd700"; 
        ctx.beginPath(); ctx.arc(barX + 22, barY + barH/2, 10, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle="#fff"; 
        ctx.font="bold 18px sans-serif"; 
        ctx.textAlign="left"; 
        ctx.fillText(`${credits}`, barX + 45, textY);
        // --- Fin Affichage Cr√©dits ---

    } else if(state===STATE.GAMEOVER){
        const finalScore = Math.floor(score);
        
        ctx.fillStyle="#fff"; 
        ctx.font="bold 45px sans-serif"; 
        ctx.textAlign="center"; 
        ctx.fillText("CRASH SYST√àME", 210, 250); 

        // AFFICHAGE DU SCORE
        ctx.font="bold 30px sans-serif"; 
        ctx.fillStyle = curCol;
        ctx.fillText(`SCORE: ${finalScore}`, 210, 320); 
        
        ctx.font="20px sans-serif"; 
        ctx.fillStyle = "#aaa";
        ctx.fillText(`Meilleur: ${bestScore}`, 210, 360); 
        
        ctx.font="18px sans-serif"; 
        ctx.fillStyle = "#fff";
        ctx.fillText("Clique pour atterrir", 210, 420);
        
    } else if (state===STATE.LOADING) {
        // Barre de progression am√©lior√©e
        ctx.fillStyle="rgba(255,255,255,0.1)"; 
        ctx.fillRect(110, 400, 200, 20);
        
        const gradient = ctx.createLinearGradient(110, 400, 110 + (200 * loadingProgress/100), 420);
        gradient.addColorStop(0, "#00d9ff");
        gradient.addColorStop(1, "#0066ff");
        ctx.fillStyle=gradient;
        ctx.fillRect(110, 400, 200 * loadingProgress/100, 20);
        
        ctx.strokeStyle = "#00d9ff";
        ctx.lineWidth = 2;
        ctx.strokeRect(110, 400, 200, 20);
        
        ctx.fillStyle="#fff"; 
        ctx.font="bold 16px sans-serif"; 
        ctx.textAlign="center"; 
        ctx.fillText(`${Math.floor(loadingProgress)}%`, 210, 415);
        
        ctx.font="bold 30px sans-serif"; 
        ctx.fillText("CONNEXION AU SYST√àME...", 210, 360);
        
        // Vaisseau en rotation avec particules
        ctx.save();
        ctx.translate(loadingShip.x, loadingShip.y - 50);
        ctx.rotate(loadingShip.angle);
        
        const sD_load = ships[0]; 
        ctx.fillStyle=sD_load.flame; 
        ctx.beginPath(); ctx.moveTo(-8,20); ctx.lineTo(0,25+Math.sin(time*0.3)*5); ctx.lineTo(8,20); ctx.fill(); 
        ctx.shadowBlur=25; ctx.shadowColor="#00d9ff"; 
        ctx.fillStyle=sD_load.color; 
        ctx.beginPath(); 
        ctx.moveTo(0,-22); ctx.lineTo(16,18); ctx.lineTo(0,10); ctx.lineTo(-16,18); ctx.fill(); 
        ctx.fillStyle=sD_load.cockpit; 
        ctx.beginPath(); ctx.arc(0,-4,6,0,Math.PI*2); ctx.fill(); 
        ctx.restore();
        
        // Particules du vaisseau
        loadingShip.particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = "#00d9ff";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        });
    }

    floatingTexts.forEach(t => {
        ctx.save(); 
        ctx.globalAlpha = t.alpha; 
        ctx.fillStyle = t.color || "#fff"; 
        ctx.font = "bold 20px sans-serif";
        ctx.textAlign = "center"; 
        ctx.fillText(t.text, t.x, t.y); 
        ctx.restore();
    });

    if(state === STATE.PLAY) { 
        const barX = 5, barY = 5, barW = GAME_WIDTH - 10, barH = 30, barR = 8;
        const textY = barY + barH/2 + 5; 
        
        // 1. Dessin du fond sombre semi-transparent
        ctx.fillStyle="rgba(0, 0, 0, 0.7)"; 
        drawRoundedRect(barX, barY, barW, barH, barR, true, false); 

        // 2. Dessin du contour n√©on (utilise curCol)
        ctx.strokeStyle = curCol; 
        ctx.lineWidth = 2;
        drawRoundedRect(barX, barY, barW, barH, barR, false, true, curCol, 15); 
        
        // 3. Dessin des textes
        ctx.fillStyle="#fff"; ctx.font="bold 14px sans-serif"; ctx.textAlign="left"; ctx.fillText(`üéØ ${Math.floor(score)}`, 15, textY); 
        ctx.fillStyle=curCol; ctx.fillText(`LVL ${currentLevel}`, 75, textY); 
        ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.fillText(`üèÜ ${bestScore}`, 210, textY); 
        ctx.textAlign="right"; ctx.fillText(`üí∞ ${credits}`, 405, textY); 
    }

    if(flashAlpha > 0) { ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT); }
    if(coinFlashAlpha > 0) { ctx.fillStyle = `rgba(255,215,0,${coinFlashAlpha})`; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT); }
    
    if (transition.active) { 
        ctx.globalAlpha = transition.alpha; 
        ctx.fillStyle = "#000"; 
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); 
        ctx.globalAlpha = 1.0; 
    }
}

function drawBtn(t, x, y, w, h, c, scale = 1, alpha = 1, r = 10){ 
    const hover = mouseInRect(x-w/2, y, w, h); 
    if(hover) canvas.style.cursor = "pointer";
    
    if (alpha === 1) {
        const sizeMod = hover ? 1.05 : 1.0; 
        
        ctx.save(); ctx.translate(x, y + h/2); ctx.scale(sizeMod, sizeMod);
        ctx.shadowBlur = hover ? 35 : 10; ctx.shadowColor = c;
        ctx.fillStyle = hover ? c : "rgba(255,255,255,0.05)"; ctx.strokeStyle = c; ctx.lineWidth = 2/sizeMod; 
        
        drawRoundedRect(-w/2, -h/2, w, h, r/sizeMod, true, true); 

        ctx.shadowBlur = 0; ctx.fillStyle = hover ? "#000" : "#fff"; ctx.font = "bold 18px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(t, 0, 0); ctx.restore();
    
    } 
    else {
        ctx.save(); ctx.globalAlpha = alpha; 
        ctx.translate(x, y + h/2); ctx.scale(scale, scale);
        
        ctx.shadowBlur = hover ? 45 : 20; ctx.shadowColor = c;
        ctx.fillStyle = hover ? c : "rgba(255,255,255,0.1)"; ctx.strokeStyle = c; ctx.lineWidth = 3/scale; 
        
        drawRoundedRect(-w/2, -h/2, w, h, r/scale, true, true); 
        
        ctx.shadowBlur = 0; ctx.fillStyle = hover ? "#000" : "#fff"; ctx.font = "bold 22px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(t, 0, 0); ctx.restore();
    }
}

function wrapText(t,x,y,mW,lH){ let words=t.split(' '), line=''; for(let n=0;n<words.length;n++){ let test=line+words[n]+' '; if(ctx.measureText(test).width>mW && n>0){ ctx.fillText(line,x,y); line=words[n]+' '; y+=lH; } else line=test; } ctx.fillText(line,x,y); }

function drawRoundedRect(x, y, w, h, r, fill = true, stroke = true, shadowC = null, shadowB = 0){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.arcTo(x + w, y, x + w, y + r, r);
    ctx.lineTo(x + w, y + h - r);
    ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
    ctx.lineTo(x + r, y + h);
    ctx.arcTo(x, y + h, x, y + h - r, r);
    ctx.lineTo(x, y + r);
    ctx.arcTo(x, y, x + r, y, r);
    ctx.closePath();

    if (shadowC) {
        ctx.shadowColor = shadowC;
        ctx.shadowBlur = shadowB;
    }

    if (fill) {
        ctx.fill();
    }
    
    if (stroke) {
        ctx.stroke();
    }
    
    ctx.shadowBlur = 0; 
    ctx.shadowColor = "#000"; 
}


function loop(){ 
    update(); 
    draw(); 
    requestAnimationFrame(loop); 
}

resizeCanvas();
draw(); 
loadGameData(); 
loop(); 
</script>
</body>
</html>