<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Astro Dodge</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* CSS pour le Responsive */
body { 
    margin:0; 
    background: #0a0e27; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    height:100vh; 
    color:#fff; 
    font-family:sans-serif; 
    overflow:hidden; 
}
canvas { 
    background: #020510; 
    border:3px solid #00d9ff; 
    box-shadow: 0 0 40px rgba(0,217,255,0.8); 
    border-radius: 8px; 
    max-width: calc((100vh - 6px) * 420 / 640);
    max-height: calc((100vw - 6px) * 640 / 420);
    width: 100%;
    height: 100%;
    object-fit: contain;
}
</style>
</head>
<body>
<canvas id="game"></canvas> 
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

// --- CONFIGURATION API IMPORTANTE ---
const API_BASE_URL = "https://project-3-api-2bgb.onrender.com/astro"; 
// ------------------------------------

// Dimensions Virtuelles du Jeu (r√©f√©rence pour tous les dessins)
const GAME_WIDTH = 420;
const GAME_HEIGHT = 640;

let scaleFactor = 1;

// --- FONCTION DE REDIMENSIONNEMENT RESPONSIVE ---
function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    scaleFactor = canvas.width / GAME_WIDTH;
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    ctx.scale(scaleFactor, scaleFactor);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

// --- GESTION DES COORDONN√âES SOURIS/TOUCH MISES √Ä L'√âCHELLE ---
let mouseX = 0, mouseY = 0, isMouseDown = false;

function getScaledMouseCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const virtualX = (clientX - rect.left) / scaleFactor;
    const virtualY = (clientY - rect.top) / scaleFactor;
    return { x: virtualX, y: virtualY };
}

canvas.addEventListener("mousemove", e => { 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mousedown", e => { 
    isMouseDown = true; 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mouseup", () => isMouseDown = false);
canvas.addEventListener("touchstart", e => {
    isMouseDown = true;
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchmove", e => {
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchend", () => isMouseDown = false);

function mouseInRect(x,y,w,h){ return mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h; }

// --- CONSTANTES ET INITIALISATION DU JEU ---
const STATE={MENU:0,PLAY:1,GAMEOVER:2,SHOP:3, TAKEOFF:4, LANDING:5, LEADERBOARD:6, LOADING: 7};
let state=STATE.LOADING; // D√âMARRER EN √âTAT DE CHARGEMENT

let transition = { active: false, alpha: 0, nextState: null, callback: null };

let username = localStorage.getItem("username") || "Invit√©"; // SEUL username est conserv√©
let score=0, bestScore=0, credits=0; 
let time=0, spawnTimer=0, asteroids=[], stars=[], coins=[], keys={}, explosion=null, flashAlpha=0;
let coinFlashAlpha = 0, floatingTexts = [], shopScroll=0;
// Note: player.type stocke l'INDEX du vaisseau actuellement s√©lectionn√©
let player={x:210,y:560,r:18,type:0,life:1, invulnerable:0, trail:[], angle:0};
let leaderboardData = []; 
let loadingShip = { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, angle: 0, r: 20 }; // Pour l'animation de chargement

let menuParticles = [];
for(let i=0; i<25; i++) menuParticles.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, l: Math.random()*30+10, s: Math.random()*8+4});

let nebulas = [];
function initNebulas() {
  nebulas = [];
  const colors = ["rgba(100, 0, 255, 0.08)", "rgba(0, 150, 255, 0.08)", "rgba(255, 0, 150, 0.08)"];
  for(let i=0; i<3; i++) nebulas.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, r: 150+Math.random()*150, color: colors[i], speed: 0.15+Math.random()*0.1});
}
initNebulas();

let launchProgress = 0, earthY = 0, deathShockwave = { active: false, r: 0, alpha: 0, x: 0, y: 0 }, timeScale = 1, glitchTimer = 0;
let currentLevel = 1, levelAnimTimer = 0, colorIndex = 0;
const levelColors = ["#00d9ff", "#ff00ea", "#00ff88", "#ff3300", "#ffcc00", "#9d00ff"];

const ships=[
{name:"Standard", cost:0, speed:5, unlocked:true, color:"#0288d1", cockpit:"#81d4fa", flame:"#ff7043", bonus:"Aucun", desc:"Stable et √©quilibr√©."},
{name:"Rapide", cost:1000, speed:8, unlocked:false, color:"#d32f2f", cockpit:"#ff8a80", flame:"#ffeb3b", bonus:"Vitesse +2", desc:"Esquives √©clairs."},
{name:"Double Pi√®ces", cost:1500, speed:5, unlocked:false, color:"#388e3c", cockpit:"#a5d6a7", flame:"#ff9800", bonus:"Pi√®ces x2", desc:"Richesse instantan√©e."},
{name:"Score Boost", cost:2000, speed:5, unlocked:false, color:"#7b1fa2", cockpit:"#ce93d8", flame:"#f48fb1", bonus:"Score x2", desc:"Progression rapide."},
{name:"magnet", cost:2500, speed:5, unlocked:false, color:"#ffde21", cockpit:"#ce93d8", flame:"#c2185b", bonus:"Aim Magn√©tique", desc:"Attire l'or √† distance."},
{name:"Titan", cost:5000, speed:5, unlocked:false, color:"#ff6f00", cockpit:"#ffcc80", flame:"#ff1744", bonus:"Vie Suppl√©mentaire", desc:"Blindage renforc√©."}
];

// Suppression des anciens stockages locaux (pour la transition vers l'API)
function clearOldLocalStorage() {
    ["astro_best", "astro_credits", "astro_unlocked_ships"].forEach(key => {
        localStorage.removeItem(key);
    });
}
clearOldLocalStorage(); 

function changeState(newState, callback = null) {
  if (transition.active) return;
  transition.active = true; transition.alpha = 0; transition.nextState = newState; transition.callback = callback;
}

function updateTransition() {
  if (!transition.active) return;
  if (transition.nextState !== null) {
    transition.alpha += 0.05; 
    if (transition.alpha >= 1) { 
        state = transition.nextState; 
        transition.nextState = null; 
        if (transition.callback) transition.callback(); 
    }
  } else {
    transition.alpha -= 0.05; 
    if (transition.alpha <= 0) { 
        transition.alpha = 0; 
        transition.active = false; 
    }
  }
}

// =================================================================
// --- PARTIE 1: CORRECTION DE LA LOGIQUE DE CHARGEMENT DE DONN√âES ---
// =================================================================
async function loadGameData() {
    // L'√©tat est d√©j√† STATE.LOADING au d√©marrage
    try {
        const response = await fetch(`${API_BASE_URL}/load_data/${username}`);
        const result = await response.json();

        if (result.status === "success" || result.status === "not_found") {
            const data = result.data;

            bestScore = Number(data.PR_Score) || 0;
            credits = Number(data.Coins) || 0;
            
            // 1. Lire la cha√Æne des voitures d√©bloqu√©es (ex: "Standard,Rapide,Titan")
            const unlockedCarsString = data.Voiture || "Standard"; 
            const unlockedCarsArray = unlockedCarsString.split(',');

            // 2. Mettre √† jour l'√©tat `unlocked` de tous les vaisseaux
            let selectedShipName = ships[player.type].name; // Conserver le nom du vaisseau actuellement s√©lectionn√©
            let firstUnlockedIndex = 0;
            
            ships.forEach((ship, i) => {
                // D√©bloquer le vaisseau si son nom est dans la liste re√ßue
                ship.unlocked = unlockedCarsArray.includes(ship.name);
                if(i === 0) ship.unlocked = true; // S'assurer que Standard est toujours d√©bloqu√©
                
                // Si le vaisseau actuel n'est plus d√©bloqu√©, revenir au premier d√©bloqu√©.
                if (ship.unlocked && firstUnlockedIndex === 0) {
                    firstUnlockedIndex = i;
                }
            });

            // 3. D√©terminer le vaisseau s√©lectionn√©.
            // On cherche le dernier vaisseau d√©bloqu√© (pour garder la s√©lection du client si elle est valide)
            const savedShipIndex = ships.findIndex(s => s.name === selectedShipName && s.unlocked);
            player.type = savedShipIndex !== -1 ? savedShipIndex : firstUnlockedIndex;

            // Correction pour le passage au menu
            state = STATE.MENU;
            transition.active = false;
            transition.nextState = null;
            
            console.log("Donn√©es charg√©es depuis l'API:", data);
            console.log("Voitures d√©bloqu√©es:", unlockedCarsArray);

        } else {
            console.error("Erreur de chargement des donn√©es:", result.message);
            state = STATE.MENU;
            transition.active = false;
        }
    } catch (e) {
        console.error("Erreur de connexion API au chargement:", e);
        state = STATE.MENU; 
        transition.active = false;
    }
}


// =================================================================
// --- PARTIE 2: CORRECTION DE LA LOGIQUE DE SAUVEGARDE DE DONN√âES ---
// =================================================================
async function saveGameData(newScore = null) {
    if (username === "Invit√©") return; 

    // Construire la liste des noms des vaisseaux d√©bloqu√©s (format: "Nom1,Nom2,Nom3")
    const unlockedCarsNames = ships
        .filter(s => s.unlocked)
        .map(s => s.name)
        .join(',');

    const dataToSave = {
        username: username,
        Coins: credits, 
        // Sauvegarder la liste des voitures d√©bloqu√©es (Voiture)
        Voiture: unlockedCarsNames 
    };
    
    // N'inclure PR_Score que si un nouveau score est fourni (fin de partie)
    if (newScore !== null) {
        dataToSave.PR_Score = Math.floor(newScore);
    }

    try {
        const response = await fetch(`${API_BASE_URL}/save_data`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(dataToSave)
        });
        const result = await response.json();
        
        if (result.status !== "success") {
            console.warn("Erreur de sauvegarde des donn√©es:", result.message);
        } else {
             console.log("Donn√©es sauvegard√©es avec succ√®s.");
        }
    } catch (e) {
        console.error("Erreur de connexion API √† la sauvegarde:", e);
    }
}


// --- LOGIQUE API: CLASSEMENT ---
async function loadLeaderboard() {
    try {
        const response = await fetch(`${API_BASE_URL}/leaderboard`);
        const result = await response.json();
        
        if (result.status === "success") {
            // L'API renvoie maintenant le top 5
            leaderboardData = result.leaderboard;
            
            // Pr√©parer le classement pour l'affichage (max 5 joueurs du top + le joueur si hors top)
            leaderboardData = leaderboardData.map(e => ({
                name: (e.username === username ? "Vous" : e.username), 
                score: e.PR_Score
            })).sort((a, b) => b.score - a.score).slice(0, 5); // Limit√© au TOP 5
            
            // Ajouter le joueur s'il n'est pas dans le top 5
            if (!leaderboardData.some(e => e.name === "Vous")) {
                leaderboardData.push({ name: "Vous", score: bestScore });
            }
            
        } else {
            console.error("Erreur de chargement du classement:", result.message);
        }
    } catch (e) {
        console.error("Erreur de connexion API au classement:", e);
    }
}

// --- GESTION DES INPUTS (MISE √Ä JOUR DE LA LOGIQUE D'ACHAT) ---
canvas.addEventListener("click", e=>{
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    
    if (transition.active) return; 
    if(state===STATE.MENU){
      if(mouseInRect(110, 240, 200, 50)) changeState(STATE.TAKEOFF, startLaunchAnimation);
      if(mouseInRect(110, 310, 200, 50)) changeState(STATE.SHOP);
      if(mouseInRect(110, 380, 200, 50)) changeState(STATE.LEADERBOARD, loadLeaderboard); 
      if(mouseInRect(110, 450, 200, 50)) window.location.href = "../../menu.html"; 
    } else if(state===STATE.SHOP || state===STATE.LEADERBOARD){
      if(mouseInRect(110, 540, 200, 50)) changeState(STATE.MENU);
      if(state===STATE.SHOP){
        ships.forEach((s,i)=>{
          const cardY=140+i*160 - shopScroll;
          if(mouseInRect(40, cardY, 340, 140)){
            if(!s.unlocked && credits>=s.cost){ 
              credits-=s.cost; 
              s.unlocked=true; 
              player.type = i; // S√©lectionne imm√©diatement le nouveau vaisseau
              saveGameData(); // SAUVEGARDE la nouvelle liste de voitures et les cr√©dits
            } else if(s.unlocked) {
                player.type=i;
                saveGameData(); // Sauvegarde le changement de vaisseau (la liste d√©bloqu√©e reste la m√™me)
            }
          }
        });
      }
    } else if(state===STATE.GAMEOVER && flashAlpha <= 0.1) {
      asteroids = []; coins = []; explosion = null; launchProgress = 1; earthY = 800; player.angle = Math.PI; state = STATE.LANDING;
    }
});

document.addEventListener("keydown", e=>{ keys[e.key]=true; if(e.key==="Escape" && (state===STATE.PLAY || state===STATE.SHOP || state===STATE.LEADERBOARD)) changeState(STATE.MENU); });
document.addEventListener("keyup", e=>keys[e.key]=false);
canvas.addEventListener("wheel", e=>{ if(state===STATE.SHOP) shopScroll = Math.max(0, Math.min(shopScroll + e.deltaY, (ships.length-1)*160)); });

function initStars(){ stars=[]; for(let i=0;i<80;i++) stars.push({x:Math.random()*GAME_WIDTH, y:Math.random()*GAME_HEIGHT, s:Math.random()*2.5+0.5, speed: Math.random()*0.3+0.1, twinkle: Math.random()*Math.PI*2}); }
initStars();

function startLaunchAnimation() {
  asteroids=[]; coins=[]; score=0; time=0; spawnTimer=0; explosion=null; flashAlpha=0; floatingTexts=[]; deathShockwave.active = false; glitchTimer = 0;
  timeScale = 1; launchProgress = 0; earthY = 500; currentLevel = 1; colorIndex = 0;
  player.x = 210; player.y = 520; player.trail = []; player.angle = 0;
  player.life=ships[player.type].bonus==="Vie Suppl√©mentaire" ? 2 : 1; state = STATE.TAKEOFF;
}

// --- FONCTION DE MISE √Ä JOUR (UPDATE) ---
function update(){
  updateTransition();
  canvas.style.cursor = "default";
  if(flashAlpha > 0) flashAlpha -= 0.05;
  if(coinFlashAlpha > 0) coinFlashAlpha -= 0.1;
  if(glitchTimer > 0) glitchTimer--;

  // Animation de l'√©cran de chargement
  if(state === STATE.LOADING) {
      loadingShip.angle += 0.08; 
  }

  if(state === STATE.MENU) {
    menuParticles.forEach(p => { p.y += p.s; if(p.y > GAME_HEIGHT) { p.y = -20; p.x = Math.random()*GAME_WIDTH; } });
  }

  floatingTexts.forEach((t, i) => { t.y -= 2; t.alpha -= 0.02; if(t.alpha <= 0) floatingTexts.splice(i, 1); });

  nebulas.forEach(n => { n.y += n.speed * (state === STATE.GAMEOVER ? timeScale : 1); if(n.y - n.r > GAME_HEIGHT) { n.y = -n.r; n.x = Math.random() * GAME_WIDTH; } });

  if(state === STATE.TAKEOFF) { launchProgress += 0.005; earthY += 4; player.y -= 0.5; if(launchProgress >= 1) state = STATE.PLAY; }
  if(state === STATE.LANDING) { launchProgress -= 0.01; earthY -= 5; player.y += 2; if(earthY <= 500) changeState(STATE.MENU); }

  if(state!==STATE.PLAY && state!==STATE.GAMEOVER && state!==STATE.TAKEOFF && state!==STATE.LANDING) return;
  
  let currentSpeed = (state === STATE.GAMEOVER) ? timeScale : 1;
  if(state === STATE.GAMEOVER && timeScale > 0) timeScale -= 0.02;

  time++; 
  if(player.invulnerable > 0) player.invulnerable--;
  const sD=ships[player.type];

  if(state === STATE.PLAY || state === STATE.TAKEOFF || state === STATE.LANDING) {
      let trailY = state === STATE.LANDING ? player.y - 15 : player.y + 15;
      if(time % 2 === 0) player.trail.push({x: player.x + (Math.random()-0.5)*10, y: trailY, r: 4 + Math.random()*4, alpha: 0.6});
  }
  player.trail.forEach((p, i) => { p.y += (state === STATE.LANDING ? -3 : 3) * currentSpeed; p.alpha -= 0.02; p.r *= 0.98; if(p.alpha <= 0) player.trail.splice(i, 1); });

  if(state === STATE.PLAY) {
    let nextLvl = Math.floor(score/500) + 1;
    if(nextLvl > currentLevel) { 
        currentLevel = nextLvl; levelAnimTimer = 100; colorIndex = (currentLevel - 1) % levelColors.length; flashAlpha = 0.3; 
        credits += 50; 
        saveGameData(); // SAUVEGARDE apr√®s gain de niveau (coins)
    }
    if(levelAnimTimer > 0) levelAnimTimer--;

    score += (sD.bonus==="Score x2" ? 1.1 : 0.55);
    spawnTimer++;
    if(spawnTimer>=Math.max(10, 40 - Math.floor(score/150))){ spawnAsteroid(); spawnTimer=0; }
    
    asteroids.forEach(a=>{
        a.y+=a.speed; a.rot+=a.rotSpeed;
        if(Math.hypot(player.x-a.x,player.y-a.y)<player.r+a.r && player.invulnerable===0){
          if(player.life>1){ player.life--; player.invulnerable=60; flashAlpha=0.4; asteroids=[]; } 
          else {
            state = STATE.GAMEOVER; flashAlpha = 1; timeScale = 1;
            
            if(Math.floor(score)>bestScore){ 
                bestScore=Math.floor(score); 
            }
            saveGameData(score); // SAUVEGARDE le score ET les coins/voitures d√©bloqu√©es

          }
        }
    });

    if(time%350===0) spawnCoin();
    if(keys.ArrowLeft) player.x-=sD.speed; if(keys.ArrowRight) player.x+=sD.speed;
    if(keys.ArrowUp) player.y-=sD.speed; if(keys.ArrowDown) player.y+=sD.speed;
    player.x=Math.max(player.r, Math.min(GAME_WIDTH-player.r, player.x));
    player.y=Math.max(player.r, Math.min(GAME_HEIGHT-player.r, player.y));
  }

  asteroids=asteroids.filter(a=>a.y<GAME_HEIGHT+50);
  coins.forEach(c=>{
    c.y+=2.5 * currentSpeed;
    if(sD.bonus==="Aim Magn√©tique" && Math.hypot(player.x-c.x,player.y-c.y)<220){ c.x+=(player.x-c.x)*0.07; c.y+=(player.y-c.y)*0.07; }
    if(Math.hypot(player.x-c.x,player.y-c.y)<player.r+c.r){ 
        const val = 50*(sD.bonus==="Pi√®ces x2"?2:1); 
        credits+=val; 
        saveGameData(); // SAUVEGARDE √† chaque collecte de pi√®ces
        c.collected=true; coinFlashAlpha = 0.3; 
        floatingTexts.push({x: c.x, y: c.y, text: `+${val} üí∞`, alpha: 1}); 
    }
  });
  coins=coins.filter(c=>c.y<GAME_HEIGHT && !c.collected);
}

function spawnAsteroid(){ const r=16+Math.random()*28; asteroids.push({x:r + Math.random()*(GAME_WIDTH-2*r), y:-r-50, r, speed:1.8 + Math.random()*1.5 + (score/800), rot:Math.random()*Math.PI*2, rotSpeed:(Math.random()-0.5)*0.05, pts:Array.from({length:7}, ()=>0.6+Math.random()*0.8)}); }
function spawnCoin(){ coins.push({x:25+Math.random()*370,y:-10,r:8,collected:false}); }

// --- FONCTION DE DESSIN (DRAW) ---
function draw(){
  const curCol = (state === STATE.MENU || state === STATE.SHOP || state === STATE.LEADERBOARD || state === STATE.LOADING) ? "#00d9ff" : levelColors[colorIndex];
  ctx.fillStyle = "#020510"; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);

  nebulas.forEach(n => { let g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r); g.addColorStop(0, n.color); g.addColorStop(1, "transparent"); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI*2); ctx.fill(); });

  if(state === STATE.MENU) {
    ctx.strokeStyle = "rgba(0, 217, 255, 0.15)"; ctx.lineWidth = 2;
    menuParticles.forEach(p => { ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + p.l); ctx.stroke(); });
  }

  stars.forEach(s=>{ ctx.fillStyle=`rgba(255,255,255,${(0.3+Math.sin(time*0.05+s.twinkle)*0.4)})`; ctx.fillRect(s.x,s.y,s.s,s.s); if(state === STATE.PLAY || state === STATE.GAMEOVER || state === STATE.TAKEOFF || state === STATE.LANDING) { let starDir = state === STATE.LANDING ? -s.speed : s.speed; s.y+=starDir * (state===STATE.GAMEOVER?timeScale:1); if(s.y>GAME_HEIGHT) s.y=0; if(s.y<0) s.y=GAME_HEIGHT; } });

  if(state === STATE.TAKEOFF || state === STATE.LANDING) { ctx.fillStyle = "#2e7d32"; ctx.beginPath(); ctx.arc(210, earthY + 400, 500, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#1565c0"; ctx.beginPath(); ctx.arc(210, earthY + 420, 480, 0, Math.PI*2); ctx.fill(); }

  if(state === STATE.PLAY || state === STATE.GAMEOVER || state === STATE.TAKEOFF || state === STATE.LANDING) {
      player.trail.forEach(p => { ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); });
      asteroids.forEach(a=>{ ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.rot); ctx.shadowBlur=12; ctx.shadowColor=curCol; const g=ctx.createRadialGradient(0,0,0,0,0,a.r); g.addColorStop(0,"#fff"); g.addColorStop(0.4, curCol); g.addColorStop(1,"#111"); ctx.fillStyle=g; ctx.beginPath(); a.pts.forEach((p,i)=>{ const ang=i/a.pts.length*Math.PI*2; ctx.lineTo(Math.cos(ang)*a.r*p, Math.sin(ang)*a.r*p); }); ctx.closePath(); ctx.fill(); ctx.restore(); });
      coins.forEach(c=>{ ctx.shadowBlur=15; ctx.shadowColor="#ffd700"; ctx.fillStyle="#ffd700"; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; });
  }

  const sD=ships[player.type];
  if(state===STATE.PLAY || state===STATE.TAKEOFF || state===STATE.LANDING || (state===STATE.GAMEOVER && timeScale > 0.5)){ 
      ctx.save(); 
      ctx.translate(player.x,player.y); 
      ctx.rotate(player.angle); 
      if(player.invulnerable>0 && Math.floor(time/5)%2===0) ctx.globalAlpha=0.3; 
      ctx.fillStyle=sD.flame; 
      ctx.beginPath(); ctx.moveTo(-8,15); ctx.lineTo(0,20+Math.sin(time*0.5)*8); ctx.lineTo(8,15); ctx.fill(); 
      ctx.shadowBlur=20; ctx.shadowColor=sD.color; 
      ctx.fillStyle=sD.color; 
      ctx.beginPath(); 
      ctx.moveTo(0,-22); ctx.lineTo(16,18); ctx.lineTo(0,10); ctx.lineTo(-16,18); ctx.fill(); 
      ctx.fillStyle=sD.cockpit; 
      ctx.beginPath(); ctx.arc(0,-4,6,0,Math.PI*2); ctx.fill(); 
      ctx.restore(); 
  }

  if(state===STATE.MENU){
    const bounce = Math.sin(time * 0.04) * 8;
    ctx.save(); ctx.translate(210, 150 + bounce); ctx.shadowBlur = 20 + Math.sin(time*0.1)*10; ctx.shadowColor = "#00d9ff"; ctx.fillStyle = "#fff"; ctx.font = "bold 52px sans-serif"; ctx.textAlign = "center"; ctx.fillText("ASTRO DODGE", 0, 0); ctx.font = "bold 12px sans-serif"; ctx.fillStyle = "rgba(0, 217, 255, 0.8)"; ctx.fillText(`Bienvenue, ${username}`, 0, 25); ctx.restore();
    drawBtn("‚ñ∂ JOUER", 210, 240, 200, 50, curCol);
    drawBtn("üõí SHOP", 210, 310, 200, 50, curCol);
    drawBtn("üèÜ CLASSEMENT", 210, 380, 200, 50, curCol);
    drawBtn("‚úñ QUITTER", 210, 450, 200, 50, "#ff3300");
  } else if(state===STATE.LEADERBOARD){
    ctx.fillStyle="#fff"; ctx.font="bold 30px sans-serif"; ctx.textAlign="center"; ctx.fillText("CLASSEMENT MONDIAL", 210, 80);
    leaderboardData.forEach((entry, i) => { const y = 160 + i * 60; const isPlayer = entry.name === "Vous"; ctx.fillStyle = isPlayer ? "rgba(0, 217, 255, 0.2)" : "rgba(255, 255, 255, 0.05)"; ctx.fillRect(40, y-35, 340, 50); ctx.fillStyle = isPlayer ? "#00d9ff" : "#fff"; ctx.textAlign = "left"; ctx.font = "bold 20px sans-serif"; ctx.fillText(`${i+1}. ${entry.name}`, 60, y); ctx.textAlign = "right"; ctx.fillText(`${entry.score}`, 360, y); });
    drawBtn("RETOUR", 210, 540, 200, 50, curCol);
  } else if(state===STATE.SHOP){
    ctx.fillStyle="#fff"; ctx.font="bold 30px sans-serif"; ctx.textAlign="center"; ctx.fillText("BOUTIQUE", 210, 75);
    ships.forEach((s,i)=>{ const cardY=140+i*160 - shopScroll; if(cardY > GAME_HEIGHT || cardY < -140) return; const hover = mouseInRect(40, cardY, 340, 140); ctx.shadowBlur=hover?25:15; ctx.shadowColor=player.type===i?"#fff":s.color; ctx.fillStyle=hover?"#252545":"#1a1a2e"; ctx.fillRect(40, cardY, 340, 140); ctx.shadowBlur=0; ctx.fillStyle="#fff"; ctx.textAlign="left"; ctx.font="bold 18px sans-serif"; ctx.fillText(s.name, 60, cardY+35); ctx.fillStyle=curCol; ctx.font="14px sans-serif"; ctx.fillText(s.bonus, 60, cardY+55); ctx.fillStyle="#aaa"; wrapText(s.desc, 60, cardY+80, 240, 16); ctx.fillStyle=s.unlocked?(player.type===i?"#00ff88":"#888"):"#ffd700"; ctx.textAlign="right"; ctx.fillText(s.unlocked?(player.type===i?"√âQUIP√â":"D√âBLOQU√â"):s.cost+" üí∞", 360, cardY+35); });
    drawBtn("RETOUR", 210, 540, 200, 50, curCol);
  } else if(state===STATE.GAMEOVER){
    ctx.fillStyle="#fff"; ctx.font="bold 45px sans-serif"; ctx.textAlign="center"; ctx.fillText("CRASH SYST√àME", 210, 300); ctx.font="18px sans-serif"; ctx.fillText("Clique pour atterrir", 210, 360);
  } else if (state===STATE.LOADING) {
    ctx.fillStyle="#fff"; ctx.font="bold 30px sans-serif"; ctx.textAlign="center"; ctx.fillText("CONNEXION AU SYST√àME...", 210, 320);
    
    // Dessin du vaisseau/objet en rotation (Animation de chargement)
    ctx.save();
    ctx.translate(loadingShip.x, loadingShip.y - 50);
    ctx.rotate(loadingShip.angle);
    
    const sD_load = ships[0]; 
    ctx.fillStyle=sD_load.flame; 
    ctx.beginPath(); ctx.moveTo(-8,20); ctx.lineTo(0,25); ctx.lineTo(8,20); ctx.fill(); 
    ctx.shadowBlur=20; ctx.shadowColor="#00d9ff"; 
    ctx.fillStyle=sD_load.color; 
    ctx.beginPath(); 
    ctx.moveTo(0,-22); ctx.lineTo(16,18); ctx.lineTo(0,10); ctx.lineTo(-16,18); ctx.fill(); 
    ctx.fillStyle=sD_load.cockpit; 
    ctx.beginPath(); ctx.arc(0,-4,6,0,Math.PI*2); ctx.fill(); 
    ctx.restore();
  }

  // AFFICHAGE DES TEXTES FLOTTANTS (+50 PIECES)
  floatingTexts.forEach(t => {
    ctx.save(); ctx.globalAlpha = t.alpha; ctx.fillStyle = "#ffd700"; ctx.font = "bold 20px sans-serif";
    ctx.textAlign = "center"; ctx.fillText(t.text, t.x, t.y); ctx.restore();
  });

  if(state === STATE.PLAY) { ctx.fillStyle="rgba(0,0,0,0.8)"; ctx.fillRect(0,0,GAME_WIDTH,40); ctx.fillStyle="#fff"; ctx.font="bold 14px sans-serif"; ctx.textAlign="left"; ctx.fillText(`üéØ ${Math.floor(score)}`, 15, 25); ctx.fillStyle=curCol; ctx.fillText(`LVL ${currentLevel}`, 75, 25); ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.fillText(`üèÜ ${bestScore}`, 210, 25); ctx.textAlign="right"; ctx.fillText(`üí∞ ${credits}`, 405, 25); }

  if(flashAlpha > 0) { ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT); }
  if(coinFlashAlpha > 0) { ctx.fillStyle = `rgba(255,215,0,${coinFlashAlpha})`; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT); }
  
  // Dessin de la transition: seulement si elle est active.
  if (transition.active) { 
    ctx.globalAlpha = transition.alpha; 
    ctx.fillStyle = "#000"; 
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); 
    ctx.globalAlpha = 1.0; 
  }
}

function drawBtn(t, x, y, w, h, c){
  const hover = mouseInRect(x-w/2, y, w, h); if(hover) canvas.style.cursor = "pointer";
  const sizeMod = hover ? 1.05 : 1.0; ctx.save(); ctx.translate(x, y + h/2); ctx.scale(sizeMod, sizeMod);
  ctx.shadowBlur = hover ? 35 : 10; ctx.shadowColor = c;
  ctx.fillStyle = hover ? c : "rgba(255,255,255,0.05)"; ctx.strokeStyle = c; ctx.lineWidth = 2/sizeMod; 
  ctx.beginPath(); ctx.rect(-w/2, -h/2, w, h); ctx.fill(); ctx.stroke();
  ctx.shadowBlur = 0; ctx.fillStyle = hover ? "#000" : "#fff"; ctx.font = "bold 18px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(t, 0, 0); ctx.restore();
}

function wrapText(t,x,y,mW,lH){ let words=t.split(' '), line=''; for(let n=0;n<words.length;n++){ let test=line+words[n]+' '; if(ctx.measureText(test).width>mW && n>0){ ctx.fillText(line,x,y); line=words[n]+' '; y+=lH; } else line=test; } ctx.fillText(line,x,y); }

// D√âMARRAGE: Lancer le chargement des donn√©es
function loop(){ 
    update(); 
    draw(); 
    requestAnimationFrame(loop); 
}

// Lancement initial: 
// 1. Affiche l'√©cran de chargement
resizeCanvas();
draw(); 

// 2. Lance l'appel API asynchrone (loadGameData)
loadGameData(); 

// 3. Lance la boucle d'animation IMM√âDIATEMENT. 
// La boucle update/draw va maintenant s'assurer que le STATE passe de LOADING √† MENU
// d√®s que loadGameData a termin√© (gr√¢ce √† la correction dans loadGameData).
loop(); 
</script>
</body>
</html>