<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Astro Dodge</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
body { 
    margin:0; 
    background: #0a0e27; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    height:100vh; 
    color:#fff; 
    font-family: 'Orbitron', sans-serif; 
    overflow:hidden; 
}
canvas { 
    background: #020510; 
    border:3px solid #00d9ff; 
    box-shadow: 0 0 40px rgba(0,217,255,0.8); 
    border-radius: 8px; 
    max-width: calc((100vh - 6px) * 420 / 640);
    max-height: calc((100vw - 6px) * 640 / 420);
    width: 100%;
    height: 100%;
    object-fit: contain;
    position: absolute; 
}

:fullscreen canvas {
    border: none;
    box-shadow: none;
}
:-webkit-full-screen canvas { border: none; box-shadow: none; }
:-moz-full-screen canvas { border: none; box-shadow: none; }
:-ms-fullscreen canvas { border: none; box-shadow: none; }
</style>
</head>
<body>
<canvas id="game"></canvas> 
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

// --- DÉTECTION MOBILE/TACTILE ---
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

// Nouvelle constante pour la police d'écriture
const FONT_FAMILY = 'Orbitron';

// =================================================================
// --- SYSTÈME DE SONS ---
// =================================================================
const AudioSystem = {
    context: null,
    sounds: {},
    masterVolume: 0.3,
    
    init() {
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            this.generateSounds();
        } catch(e) {
            console.warn("Audio non disponible");
        }
    },
    
    generateSounds() {
        // Son de bouton hover
        this.sounds.buttonHover = this.createTone(800, 0.05, 0.1, 'sine');
        
        // Son de clic
        this.sounds.buttonClick = this.createTone(600, 0.1, 0.15, 'square');
        
        // Son de fusée (moteur continu)
        this.sounds.rocket = this.createNoise(0.3, 'brown');
        
        // Son de pièce collectée
        this.sounds.coin = this.createSequence([
            {freq: 800, duration: 0.05},
            {freq: 1000, duration: 0.05},
            {freq: 1200, duration: 0.1}
        ]);
        
        // Son de crash
        this.sounds.crash = this.createExplosion();
        
        // Son de niveau suivant
        this.sounds.levelUp = this.createSequence([
            {freq: 400, duration: 0.1},
            {freq: 600, duration: 0.1},
            {freq: 800, duration: 0.15}
        ]);
        
        // Son de dégâts
        this.sounds.hit = this.createTone(200, 0.2, 0.3, 'sawtooth');
        
        // Son de frôlement (ajouté)
        this.sounds.nearMiss = this.createTone(1500, 0.03, 0.08, 'triangle');
    },
    
    createTone(freq, duration, volume, type = 'sine') {
        return () => {
            if (!this.context) return;
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = volume * this.masterVolume;
            
            osc.connect(gain);
            gain.connect(this.context.destination);
            
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
            osc.stop(this.context.currentTime + duration);
        };
    },
    
    createNoise(volume, type = 'white') {
        return () => {
            if (!this.context) return;
            const bufferSize = this.context.sampleRate * 0.5;
            const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const source = this.context.createBufferSource();
            const gain = this.context.createGain();
            const filter = this.context.createBiquadFilter();
            
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            
            source.buffer = buffer;
            gain.gain.value = volume * this.masterVolume;
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(this.context.destination);
            
            source.start();
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
            source.stop(this.context.currentTime + 0.5);
        };
    },
    
    createSequence(notes) {
        return () => {
            if (!this.context) return;
            let time = this.context.currentTime;
            
            notes.forEach(note => {
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = note.freq;
                gain.gain.value = 0.2 * this.masterVolume;
                
                osc.connect(gain);
                gain.connect(this.context.destination);
                
                osc.start(time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + note.duration);
                osc.stop(time + note.duration);
                
                time += note.duration;
            });
        };
    },
    
    createExplosion() {
        return () => {
            if (!this.context) return;
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.value = 100;
            gain.gain.value = 0.5 * this.masterVolume;
            
            osc.connect(gain);
            gain.connect(this.context.destination);
            
            osc.start();
            osc.frequency.exponentialRampToValueAtTime(20, this.context.currentTime + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
            osc.stop(this.context.currentTime + 0.5);
        };
    },
    
    play(soundName) {
        if (this.sounds[soundName]) {
            this.sounds[soundName]();
        }
    }
};

// Initialisation du système audio
AudioSystem.init();

// =================================================================
// --- CONFIGURATION API ---
// =================================================================
const API_BASE_URL = "https://project-3-api-2bgb.onrender.com/astro"; 

const GAME_WIDTH = 420;
const GAME_HEIGHT = 640;

let scaleFactor = 1;
let currentHoverButton = null; 
let lastHoveredButton = null;

function requestFullScreen(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen().catch(err => console.error("Plein écran bloqué:", err));
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen().catch(err => console.error("Plein écran bloqué:", err));
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen().catch(err => console.error("Plein écran bloqué:", err));
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen().catch(err => console.error("Plein écran bloqué:", err));
    }
}

window.onload = function() {
    resizeCanvas();
};

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    scaleFactor = canvas.width / GAME_WIDTH;
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    ctx.scale(scaleFactor, scaleFactor);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

let mouseX = 0, mouseY = 0, isMouseDown = false;

function getScaledMouseCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const virtualX = (clientX - rect.left) / scaleFactor;
    const virtualY = (clientY - rect.top) / scaleFactor;
    return { x: virtualX, y: virtualY };
}

canvas.addEventListener("mousemove", e => { 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mousedown", e => { 
    isMouseDown = true; 
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
});
canvas.addEventListener("mouseup", () => isMouseDown = false);
canvas.addEventListener("touchstart", e => {
    isMouseDown = true;
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchmove", e => {
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    e.preventDefault(); 
}, { passive: false });
canvas.addEventListener("touchend", () => isMouseDown = false);

function mouseInRect(x,y,w,h){ return mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h; }

const STATE={MENU:0,PLAY:1,GAMEOVER:2,SHOP:3, TAKEOFF:4, LANDING:5, LEADERBOARD:6, LOADING: 7, START_SCREEN: 8, OPTIONS: 9}; 
let state=STATE.LOADING; 

let transition = { active: false, alpha: 0, nextState: null, callback: null };

let username = localStorage.getItem("username") || "Invité"; 
let score=0, bestScore=0, credits=0; 
let time=0, spawnTimer=0, asteroids=[], stars=[], coins=[], keys={}, explosion=null, flashAlpha=0;
let coinFlashAlpha = 0, floatingTexts = [], shopScroll=0;
let player={x:210,y:560,r:18,type:0,life:1, invulnerable:0, trail:[], angle:0};
let leaderboardData = []; 
let loadingShip = { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, angle: 0, r: 20, particles: [] }; 
let loadingProgress = 0;
let startButtonAnim = { scale: 1, alpha: 0, hover: false, pulse: 0 }; 

let menuParticles = [];
for(let i=0; i<25; i++) menuParticles.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, l: Math.random()*30+10, s: Math.random()*8+4});

let nebulas = [];
function initNebulas() {
    nebulas = [];
    const colors = ["rgba(100, 0, 255, 0.08)", "rgba(0, 150, 255, 0.08)", "rgba(255, 0, 150, 0.08)"];
    for(let i=0; i<3; i++) nebulas.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, r: 150+Math.random()*150, color: colors[i], speed: 0.15+Math.random()*0.1});
}
initNebulas();

let launchProgress = 0, earthY = 0, deathShockwave = { active: false, r: 0, alpha: 0, x: 0, y: 0 }, timeScale = 1, glitchTimer = 0;
let currentLevel = 1, levelAnimTimer = 0, colorIndex = 0;
const levelColors = ["#00d9ff", "#ff00ea", "#00ff88", "#ff3300", "#ffcc00", "#9d00ff"];

const ships=[
{name:"Standard", cost:0, speed:5, unlocked:true, color:"#0288d1", cockpit:"#81d4fa", flame:"#ff7043", bonus:"Aucun", desc:"Stable et équilibré."},
{name:"Rapide", cost:1000, speed:8, unlocked:false, color:"#d32f2f", cockpit:"#ff8a80", flame:"#ffeb3b", bonus:"Vitesse +2", desc:"Esquives éclairs."},
{name:"Double Pièces", cost:1500, speed:5, unlocked:false, color:"#388e3c", cockpit:"#a5d6a7", flame:"#ff9800", bonus:"Pièces x2", desc:"Richesse instantanée."},
{name:"Score Boost", cost:2000, speed:5, unlocked:false, color:"#7b1fa2", cockpit:"#ce93d8", flame:"#f48fb1", bonus:"Score x2", desc:"Progression rapide."},
{name:"magnet", cost:2500, speed:5, unlocked:false, color:"#ffde21", cockpit:"#ce93d8", flame:"#c2185b", bonus:"Aim Magnétique", desc:"Attire l'or à distance."},
{name:"Titan", cost:5000, speed:5, unlocked:false, color:"#ff6f00", cockpit:"#ffcc80", flame:"#ff1744", bonus:"Vie Supplémentaire", desc:"Blindage renforcé."}
];

// --- NOUVELLE VARIABLE DE CONTRÔLE ---
let controlMode = localStorage.getItem("controlMode") || "Fleche"; // 'Fleche' ou 'Souris'

function clearOldLocalStorage() {
    ["astro_best", "astro_credits", "astro_unlocked_ships"].forEach(key => {
        localStorage.removeItem(key);
    });
}
clearOldLocalStorage(); 

function changeState(newState, callback = null) {
    if (transition.active) return;
    transition.active = true; transition.alpha = 0; transition.nextState = newState; transition.callback = callback;
}

function updateTransition() {
    if (!transition.active) return;
    if (transition.nextState !== null) {
        transition.alpha += 0.05; 
        if (transition.alpha >= 1) { 
            state = transition.nextState; 
            transition.nextState = null; 
            if (transition.callback) transition.callback(); 
        }
    } else {
        transition.alpha -= 0.05; 
        if (transition.alpha <= 0) { 
            transition.alpha = 0; 
            transition.active = false; 
        }
    }
}

// =================================================================
// --- LOGIQUE API CORRIGÉE ---
// =================================================================
async function loadGameData() {
    // Simulation de chargement avec progression
    for (let i = 0; i <= 100; i += 2) {
        loadingProgress = i;
        await new Promise(resolve => setTimeout(resolve, 20));
    }
    
    try {
        // CORRECTION 1: Utilisation de API_BASE_URL pour la requête de chargement, endpoint /astro_dodge_get_data (conformément à overview.html)
        const response = await fetch(`${API_BASE_URL}/astro_dodge_get_data`, {
            method: 'POST', 
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({'username': username})
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();

        if (result.status === "success" || result.status === "not_found") {
            const data = result.data || {};
            
            // Conversion et assignation des données
            bestScore = Number(data.PR_Score) || 0;
            credits = Number(data.Coins) || 0;
            const unlockedCarsString = data.Voiture || "Standard"; 
            const unlockedCarsArray = unlockedCarsString.split(',');
            let selectedShipName = ships[player.type].name; 
            let firstUnlockedIndex = 0;
            
            ships.forEach((ship, i) => {
                ship.unlocked = unlockedCarsArray.includes(ship.name);
                if(i === 0) ship.unlocked = true; 
                if (ship.unlocked && firstUnlockedIndex === 0) {
                    firstUnlockedIndex = i;
                }
            });

            const savedShipIndex = ships.findIndex(s => s.name === selectedShipName && s.unlocked);
            player.type = savedShipIndex !== -1 ? savedShipIndex : firstUnlockedIndex;

            state = STATE.START_SCREEN; 
            transition.active = false;
            transition.nextState = null;
        } else {
            console.error("Erreur de chargement des données (Statut non conforme):", result.message);
            // Fallback en cas d'erreur de statut de l'API
            state = STATE.START_SCREEN; 
            transition.active = false;
        }
    } catch (e) {
        console.error("Erreur de connexion API au chargement:", e.message);
        // Fallback en cas d'erreur de connexion
        state = STATE.START_SCREEN; 
        transition.active = false;
    }
}

async function saveGameData(newScore = null) {
    if (username === "Invité") return; 

    const unlockedCarsNames = ships.filter(s => s.unlocked).map(s => s.name).join(',');

    const dataToSave = {
        username: username,
        Coins: credits, 
        Voiture: unlockedCarsNames 
    };
    
    if (newScore !== null) {
        // Envoie le meilleur score actuel s'il y a un nouveau record
        dataToSave.PR_Score = Math.floor(newScore);
    }

    try {
        // CORRECTION 2: Utilisation de l'endpoint '/update_user_data' pour la sauvegarde (conformément à overview.html)
        const response = await fetch(`${API_BASE_URL}/update_user_data`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(dataToSave)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        // Le code original ne faisait rien avec le résultat de la sauvegarde, on conserve ce comportement
        // if (result.status !== "success") { console.error("Erreur à la sauvegarde des données:", result.message); }
        
    } catch (e) {
        console.error("Erreur de connexion API à la sauvegarde:", e.message);
    }
}

async function loadLeaderboard() {
    try {
        // CORRECTION 3: Utilisation de l'endpoint '/astro_dodge_leaderboard' et du method POST (conformément à overview.html)
        const response = await fetch(`${API_BASE_URL}/astro_dodge_leaderboard`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}) // Un corps JSON vide est requis pour POST
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.status === "success") {
            // S'assurer que PR_Score est un nombre pour le tri
            leaderboardData = result.leaderboard.map(e => ({
                name: (e.username === username ? "Vous" : e.username), 
                score: Number(e.PR_Score) // S'assurer que c'est un nombre
            })).sort((a, b) => b.score - a.score).slice(0, 5); 
            
            // Si le joueur n'est pas dans le top 5, l'ajouter à la fin pour référence
            if (!leaderboardData.some(e => e.name === "Vous")) {
                // S'assurer que le meilleur score est celui du joueur
                leaderboardData.push({ name: "Vous", score: bestScore });
            }
        } else {
             console.error("Erreur de chargement du classement (Statut non conforme):", result.message);
        }
    } catch (e) {
        console.error("Erreur de connexion API au classement:", e.message);
    }
}
// =================================================================
// --- FIN LOGIQUE API CORRIGÉE ---
// =================================================================

canvas.addEventListener("click", e=>{
    const coords = getScaledMouseCoordinates(e);
    mouseX = coords.x;
    mouseY = coords.y;
    
    if (transition.active) return; 

    if(state === STATE.START_SCREEN) {
        if(mouseInRect(110, 480, 200, 50)) {
            AudioSystem.play('buttonClick');
            requestFullScreen(document.documentElement); 
            changeState(STATE.MENU);
        }
    }
    
    else if(state===STATE.MENU){
        // Décalage des boutons si on est sur mobile (OPTIONS caché)
        const yLeaderboard = isMobile ? 380 : 450;
        const yQuit = isMobile ? 450 : 520;

        if(mouseInRect(110, 240, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.TAKEOFF, startLaunchAnimation); }
        if(mouseInRect(110, 310, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.SHOP); }
        
        // --- BOUTON OPTIONS (Actif uniquement sur Desktop) ---
        if(!isMobile && mouseInRect(110, 380, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.OPTIONS); }
        
        // BOUTON CLASSEMENT
        if(mouseInRect(110, yLeaderboard, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.LEADERBOARD, loadLeaderboard); }
        
        // BOUTON QUITTER
        if(mouseInRect(110, yQuit, 200, 50)) { AudioSystem.play('buttonClick'); window.location.href = "../../menu.html"; } 
        
    } else if(state===STATE.OPTIONS && !isMobile) { // OPTIONS visible uniquement sur Desktop
        // Bouton pour basculer le mode de contrôle
        if(mouseInRect(110, 240, 200, 50)) { 
            AudioSystem.play('buttonClick');
            controlMode = (controlMode === 'Fleche') ? 'Souris' : 'Fleche';
            localStorage.setItem("controlMode", controlMode);
        }
        // Bouton de retour
        if(mouseInRect(110, 540, 200, 50)) { 
            AudioSystem.play('buttonClick'); 
            changeState(STATE.MENU); 
        }
    } else if(state===STATE.SHOP || state===STATE.LEADERBOARD){
      if(mouseInRect(110, 540, 200, 50)) { AudioSystem.play('buttonClick'); changeState(STATE.MENU); }
      if(state===STATE.SHOP){
        ships.forEach((s,i)=>{
          const cardY=140+i*160 - shopScroll;
          if(mouseInRect(40, cardY, 340, 140)){
            if(!s.unlocked && credits>=s.cost){ 
              AudioSystem.play('coin');
              credits-=s.cost; 
              s.unlocked=true; 
              player.type = i;
              saveGameData(); 
            } else if(s.unlocked) {
                AudioSystem.play('buttonClick');
                player.type=i;
                saveGameData(); 
            }
          }
        });
      }
    } else if(state===STATE.GAMEOVER && flashAlpha <= 0.1) {
      AudioSystem.play('buttonClick');
      asteroids = []; coins = []; explosion = null; launchProgress = 1; earthY = 800; player.angle = Math.PI; state = STATE.LANDING;
    }
});

document.addEventListener("keydown", e=>{ 
    keys[e.key]=true; 
    // OPTIONS n'est pas accessible via ESC sur mobile (forcé à MENU)
    if(e.key==="Escape" && (state===STATE.PLAY || state===STATE.SHOP || state===STATE.LEADERBOARD || (state===STATE.OPTIONS && !isMobile))) {
        AudioSystem.play('buttonClick');
        changeState(STATE.MENU); 
    }
});
document.addEventListener("keyup", e=>keys[e.key]=false);
canvas.addEventListener("wheel", e=>{ if(state===STATE.SHOP) shopScroll = Math.max(0, Math.min(shopScroll + e.deltaY, (ships.length-1)*160)); });

function initStars(){ stars=[]; for(let i=0;i<80;i++) stars.push({x:Math.random()*GAME_WIDTH, y:Math.random()*GAME_HEIGHT, s:Math.random()*2.5+0.5, speed: Math.random()*0.3+0.1, twinkle: Math.random()*Math.PI*2}); }
initStars();

function startLaunchAnimation() {
    AudioSystem.play('rocket');
    asteroids=[]; coins=[]; score=0; time=0; spawnTimer=0; explosion=null; flashAlpha=0; floatingTexts=[]; deathShockwave.active = false; glitchTimer = 0;
    timeScale = 1; launchProgress = 0; earthY = 500; currentLevel = 1; colorIndex = 0;
    player.x = 210; player.y = 520; player.trail = []; player.angle = 0;
    player.life=ships[player.type].bonus==="Vie Supplémentaire" ? 2 : 1;
    state = STATE.TAKEOFF;
}

function update(){
    updateTransition();
    canvas.style.cursor = "default";
    if(flashAlpha > 0) flashAlpha -= 0.05;
    if(coinFlashAlpha > 0) coinFlashAlpha -= 0.1;
    if(glitchTimer > 0) glitchTimer--;

    if(state === STATE.LOADING) {
        loadingShip.angle += 0.08; 
        // Particules du vaisseau en chargement
        if(time % 3 === 0) {
            loadingShip.particles.push({ 
                x: loadingShip.x + (Math.random()-0.5)*15, 
                y: loadingShip.y + 20, 
                r: 2 + Math.random()*3, 
                alpha: 0.8, 
                speed: 2 + Math.random()*2 
            });
        }
        loadingShip.particles.forEach((p, i) => {
            p.y += p.speed;
            p.alpha -= 0.02;
            if(p.alpha <= 0) loadingShip.particles.splice(i, 1);
        });
    } else if (state === STATE.START_SCREEN) {
        const isHovering = mouseInRect(110, 480, 200, 50);
        if (isHovering) {
            startButtonAnim.scale += (1.08 - startButtonAnim.scale) * 0.15;
            if (!startButtonAnim.hover) {
                AudioSystem.play('buttonHover');
                startButtonAnim.hover = true;
            }
        } else {
            startButtonAnim.scale += (1.0 - startButtonAnim.scale) * 0.15;
            startButtonAnim.hover = false;
        }
        startButtonAnim.alpha += (1.0 - startButtonAnim.alpha) * 0.05;
        startButtonAnim.pulse += 0.05;
    }

    if(state === STATE.MENU) {
        menuParticles.forEach(p => {
            p.y += p.s;
            if(p.y > GAME_HEIGHT) {
                p.y = -20;
                p.x = Math.random()*GAME_WIDTH;
            }
        });
        // Détection hover pour sons
        const buttons = [
            {x: 110, y: 240, w: 200, h: 50, id: 'play'},
            {x: 110, y: 310, w: 200, h: 50, id: 'shop'},
        ];
        const yLeaderboard = isMobile ? 380 : 450;
        const yQuit = isMobile ? 450 : 520;

        if (!isMobile) {
            buttons.push({x: 110, y: 380, w: 200, h: 50, id: 'options'});
        }

        buttons.push({x: 110, y: yLeaderboard, w: 200, h: 50, id: 'leader'});
        buttons.push({x: 110, y: yQuit, w: 200, h: 50, id: 'quit'});

        let hovering = null;
        buttons.forEach(btn => {
            if(mouseInRect(btn.x, btn.y, btn.w, btn.h)) {
                hovering = btn.id;
            }
        });

        if(hovering && hovering !== lastHoveredButton) {
            AudioSystem.play('buttonHover');
            lastHoveredButton = hovering;
        } else if(!hovering) {
            lastHoveredButton = null;
        }
    }

    floatingTexts.forEach((t, i) => {
        t.y -= 2;
        t.alpha -= 0.02;
        if(t.alpha <= 0) floatingTexts.splice(i, 1);
    });

    nebulas.forEach(n => {
        n.y += n.speed * (state === STATE.GAMEOVER ? timeScale : 1);
        if(n.y - n.r > GAME_HEIGHT) {
            n.y = -n.r;
            n.x = Math.random() * GAME_WIDTH;
        }
    });

    if(state === STATE.TAKEOFF) {
        launchProgress += 0.005;
        earthY += 4;
        player.y -= 0.5;
        if(launchProgress >= 1) {
            AudioSystem.play('rocket');
            state = STATE.PLAY;
        }
    }

    if(state === STATE.LANDING) {
        launchProgress -= 0.01;
        earthY -= 5;
        player.y += 2;
        if(earthY <= 500) changeState(STATE.MENU);
    }
    
    if(state!==STATE.PLAY && state!==STATE.GAMEOVER && state!==STATE.TAKEOFF && state!==STATE.LANDING) return;
    
    let currentSpeed = (state === STATE.GAMEOVER) ? timeScale : 1;
    if(state === STATE.GAMEOVER && timeScale > 0) timeScale -= 0.02;

    time++;
    if(player.invulnerable > 0) player.invulnerable--;

    const sD=ships[player.type];

    if(state === STATE.PLAY || state === STATE.TAKEOFF || state === STATE.LANDING) {
        let trailY = state === STATE.LANDING ? player.y - 15 : player.y + 15;
        if(time % 2 === 0) player.trail.push({x: player.x + (Math.random()-0.5)*10, y: trailY, r: 4 + Math.random()*4, alpha: 0.6});
    }

    player.trail.forEach((p, i) => {
        p.y += (state === STATE.LANDING ? -3 : 3) * currentSpeed;
        p.alpha -= 0.02;
        p.r *= 0.98;
        if(p.alpha <= 0) player.trail.splice(i, 1);
    });
    
    if(state === STATE.PLAY) {
        let nextLvl = Math.floor(score/500) + 1;
        if(nextLvl > currentLevel) {
            currentLevel = nextLvl;
            levelAnimTimer = 100;
            colorIndex = (currentLevel - 1) % levelColors.length;
            flashAlpha = 0.3;
            credits += 50;
            AudioSystem.play('levelUp');
            saveGameData();
        }
        if(levelAnimTimer > 0) levelAnimTimer--;

        score += (sD.bonus==="Score x2" ? 1.1 : 0.55);

        spawnTimer++;
        if(spawnTimer>=Math.max(10, 40 - Math.floor(score/150))){
            spawnAsteroid();
            spawnTimer=0;
        }

        let targetAngle = 0;

        // --- LOGIQUE DE CONTRÔLE MISE À JOUR ---
        // Force 'Souris' control mode if on mobile
        const effectiveControlMode = isMobile ? 'Souris' : controlMode;

        if (effectiveControlMode === 'Fleche') {
            // Contrôle par flèches (Desktop)
            if(keys.ArrowLeft) { player.x-=sD.speed; targetAngle = -0.8; }
            if(keys.ArrowRight) { player.x+=sD.speed; targetAngle = 0.8; }
            if(keys.ArrowUp) player.y-=sD.speed;
            if(keys.ArrowDown) player.y+=sD.speed;
        } else {
            // Contrôle par souris/doigt (Souris/Mobile)
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const distance = Math.hypot(dx, dy);

            if (distance > 5) { // Seuil pour éviter les tremblements
                const angle = Math.atan2(dy, dx);
                player.x += Math.cos(angle) * sD.speed;
                player.y += Math.sin(angle) * sD.speed;

                // Calcul de l'angle d'inclinaison pour le dessin
                targetAngle = Math.max(-0.8, Math.min(0.8, dx/100)); 
            }
            if (distance < 5 && distance > 0) {
                 player.x = mouseX;
                 player.y = mouseY;
            }
            if(isMobile) canvas.style.cursor = "none";
        }
        
        // Lissage de l'angle
        player.angle += (targetAngle - player.angle) * 0.1;

        // Limites du joueur
        player.x=Math.max(player.r, Math.min(GAME_WIDTH-player.r, player.x));
        player.y=Math.max(player.r, Math.min(GAME_HEIGHT-player.r, player.y));
        
        // Mise à jour de la position des étoiles
        stars.forEach(s=>s.y+=s.speed);
        stars.filter(s=>s.y>GAME_HEIGHT).forEach(s=>{s.y=-10; s.x=Math.random()*GAME_WIDTH;});

        // Mise à jour des pièces
        coins.forEach(c=>{c.y+=c.speed; c.rX += c.rS;});
        coins.filter(c=>c.y>GAME_HEIGHT+20).forEach((c,i)=>coins.splice(i,1));

        // Mise à jour des astéroïdes
        asteroids.forEach(a=>{ a.y+=a.speed*currentSpeed; a.angle+=a.rot*currentSpeed; });
        asteroids.filter(a=>a.y>GAME_HEIGHT+40).forEach((a,i)=>asteroids.splice(i,1));

        // Collision joueur / astéroïdes
        asteroids.forEach(a=>{
            const dist = Math.hypot(player.x-a.x, player.y-a.y);
            
            // Détection de frôlement
            if (player.invulnerable <= 0 && dist < a.r + player.r + 25 && dist > a.r + player.r + 5 && !a.nearMissed) {
                a.nearMissed = true; 
                score += 50; 
                floatingTexts.push({x: player.x, y: player.y, text: "+50 FRÔLEMENT", alpha: 1, color: "#ffeb3b"});
                AudioSystem.play('nearMiss');
            }

            if(dist < a.r + player.r && player.invulnerable <= 0) {
                player.life--;
                flashAlpha = 1;
                player.invulnerable = 120; // 2 secondes
                AudioSystem.play('hit');
                
                if(player.life <= 0){
                    deathShockwave = { active: true, r: 0, alpha: 1, x: player.x, y: player.y };
                    timeScale = 0.1;
                    glitchTimer = 30;
                    explosion = {x: player.x, y: player.y, r: 0, alpha: 1};
                    AudioSystem.play('crash');
                    
                    if(Math.floor(score) > bestScore) {
                        bestScore = Math.floor(score);
                        saveGameData(bestScore); // Sauvegarde du nouveau record
                    }
                    saveGameData(); // Sauvegarde des crédits
                    changeState(STATE.GAMEOVER, ()=>console.log("Game Over"));
                }
            }
        });

        // Collision joueur / pièces
        coins.forEach(c=>{
            const dist = Math.hypot(player.x-c.x, player.y-c.y);
            const isMagnet = ships[player.type].bonus==="Aim Magnétique";

            if(isMagnet && dist < 100){
                c.x += (player.x - c.x) * 0.1;
                c.y += (player.y - c.y) * 0.1;
            }

            if(dist < c.r + player.r) {
                AudioSystem.play('coin');
                coins.splice(coins.indexOf(c), 1);
                const coinAmount = ships[player.type].bonus==="Double Pièces" ? 2 : 1;
                credits += coinAmount;
                coinFlashAlpha = 1;
                floatingTexts.push({x: c.x, y: c.y, text: `+${coinAmount}`, alpha: 1, color: "#ffde21"});
            }
        });
    }

    if(state === STATE.GAMEOVER) {
        // Mise à jour de l'explosion
        if(explosion){
            explosion.r += 3;
            explosion.alpha -= 0.02;
            if(explosion.alpha <= 0) explosion = null;
        }

        if(deathShockwave.active){
            deathShockwave.r += 10;
            deathShockwave.alpha -= 0.03;
            if(deathShockwave.alpha <= 0) deathShockwave.active = false;
        }
    }
}

function spawnAsteroid(){
    const r=Math.random()*15+15;
    const x=Math.random()*(GAME_WIDTH-r*2)+r;
    const speed=Math.random()*1.5+3 + currentLevel * 0.5;
    const rot=Math.random()*0.05-0.025;
    const type=Math.random()>0.9 ? 1 : 0; // 10% de chance pour une pièce
    
    if(type === 1) {
        coins.push({x: x, y: -20, r: 10, speed: speed, rX: 0, rS: Math.random()*0.1-0.05});
    } else {
        asteroids.push({x: x, y: -20, r: r, speed: speed, angle: Math.random()*Math.PI*2, rot: rot, color: `hsl(${Math.random()*360}, 50%, 50%)`});
    }
}

function drawStar(x, y, s, color="rgba(255,255,255,0.8)") {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, s, 0, Math.PI * 2);
    ctx.fill();
}

function drawNebula(n) {
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = n.color;
    ctx.beginPath();
    ctx.filter = `blur(${n.r/3}px)`;
    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.filter = 'none';
    ctx.restore();
}

function drawPlayer(p){
    const sD=ships[p.type];
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);
    
    // Traînée
    p.trail.forEach(t=>{
        ctx.fillStyle = `rgba(255, 100, 0, ${t.alpha})`;
        ctx.beginPath();
        ctx.arc(t.x-p.x, t.y-p.y, t.r, 0, Math.PI*2);
        ctx.fill();
    });

    // Moteur
    const flameColor = sD.flame;
    const flameHeight = 15 + Math.sin(time*0.5)*5;

    ctx.fillStyle = `rgba(255, 100, 0, 0.9)`;
    ctx.beginPath();
    ctx.moveTo(-10, 20);
    ctx.lineTo(0, 20 + flameHeight);
    ctx.lineTo(10, 20);
    ctx.fill();
    
    ctx.fillStyle = sD.flame;
    ctx.beginPath();
    ctx.moveTo(-5, 20);
    ctx.lineTo(0, 20 + flameHeight * 0.7);
    ctx.lineTo(5, 20);
    ctx.fill();

    // Corps du vaisseau
    ctx.fillStyle = sD.color;
    ctx.beginPath();
    ctx.moveTo(0, -p.r);
    ctx.lineTo(-p.r, p.r);
    ctx.lineTo(p.r, p.r);
    ctx.closePath();
    ctx.fill();

    // Ailes (ajout de détails)
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    ctx.moveTo(-p.r, p.r);
    ctx.lineTo(-p.r-5, p.r+10);
    ctx.lineTo(-p.r/2, p.r);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(p.r, p.r);
    ctx.lineTo(p.r+5, p.r+10);
    ctx.lineTo(p.r/2, p.r);
    ctx.closePath();
    ctx.fill();

    // Cockpit
    ctx.fillStyle = sD.cockpit;
    ctx.beginPath();
    ctx.arc(0, 0, p.r/2, 0, Math.PI*2);
    ctx.fill();

    // Effet d'invulnérabilité
    if(p.invulnerable > 0) {
        ctx.strokeStyle = `rgba(0, 217, 255, ${p.invulnerable % 30 < 15 ? 0.8 : 0.3})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, p.r + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Système de vies
    if(p.life > 1){
        ctx.fillStyle = "rgba(0,255,100, 0.8)";
        ctx.font = `bold 16px ${FONT_FAMILY}`;
        ctx.textAlign = "center";
        ctx.fillText(`+${p.life - 1}`, 0, -25);
    }

    ctx.restore();
}

function drawAsteroid(a){
    ctx.save();
    ctx.translate(a.x, a.y);
    ctx.rotate(a.angle);
    ctx.fillStyle = a.color;
    ctx.beginPath();
    // Forme d'astéroïde irrégulière
    for(let i=0; i<8; i++){
        const angle = i/8 * Math.PI*2;
        const radius = a.r + Math.sin(angle*5+time*0.01)*3 + Math.random()*5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    
    // Ombre (lumière venant d'en haut)
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    ctx.beginPath();
    ctx.arc(a.r/3, a.r/3, a.r*0.8, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
}

function drawCoin(c){
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(c.rX);
    ctx.fillStyle = "#ffde21";
    ctx.beginPath();
    ctx.ellipse(0, 0, c.r, c.r * (Math.abs(Math.cos(c.rX*5)) * 0.5 + 0.5), 0, 0, Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = "#a16d00";
    ctx.beginPath();
    ctx.ellipse(0, 0, c.r/3, c.r/3 * (Math.abs(Math.cos(c.rX*5)) * 0.5 + 0.5), 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
}

function drawText(t, x, y, size, color="#fff", align="center", baseline="middle"){
    ctx.fillStyle = color;
    ctx.font = `bold ${size}px ${FONT_FAMILY}`;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    ctx.fillText(t, x, y);
}

function drawButton(t, x, y, w, h, r=10, color="#00d9ff", hover=false, shadow=true){
    ctx.save();
    ctx.translate(x+w/2, y+h/2);

    if(hover) {
        ctx.scale(1.05, 1.05);
        ctx.shadowColor = color;
        ctx.shadowBlur = 25;
        canvas.style.cursor = "pointer";
    }

    ctx.strokeStyle = color;
    ctx.fillStyle = hover ? color : "rgba(0,0,0,0.5)";
    ctx.lineWidth = 3/scaleFactor; 
    
    drawRoundedRect(-w/2, -h/2, w, h, r, true, true); 
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = hover ? "#000" : color;
    ctx.font = `bold 22px ${FONT_FAMILY}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(t, 0, 0);
    ctx.restore();
}

function drawRoundedRect(x, y, w, h, r, fill = true, stroke = true, shadowC = null, shadowB = 0){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.arcTo(x + w, y, x + w, y + r, r);
    ctx.lineTo(x + w, y + h - r);
    ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
    ctx.lineTo(x + r, y + h);
    ctx.arcTo(x, y + h, x, y + h - r, r);
    ctx.lineTo(x, y + r);
    ctx.arcTo(x, y, x + r, y, r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
}

function wrapText(t,x,y,mW,lH){ 
    let words=t.split(' '), line=''; 
    for(let n=0;n<words.length;n++){ 
        let test=line+words[n]+' '; 
        if(ctx.measureText(test).width>mW && n>0){ 
            ctx.fillText(line,x,y); 
            line=words[n]+' '; 
            y+=lH; 
        } else line=test; 
    } 
    ctx.fillText(line,x,y); 
}

function draw(t){
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Fond (Étoiles)
    ctx.fillStyle = "#020510";
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    nebulas.forEach(drawNebula);
    stars.forEach(s => drawStar(s.x, s.y, s.s, `rgba(255, 255, 255, ${0.4 + Math.sin(s.twinkle + time*0.1)*0.4})`));

    // Dessin en fonction de l'état
    if(state === STATE.LOADING) {
        drawText("CHARGEMENT...", GAME_WIDTH/2, 100, 30, "#00d9ff");
        drawText(loadingProgress + "%", GAME_WIDTH/2, GAME_HEIGHT - 100, 20, "#fff");
        
        ctx.save();
        ctx.translate(loadingShip.x, loadingShip.y);
        ctx.rotate(loadingShip.angle);
        
        loadingShip.particles.forEach(p=>{
            ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x-loadingShip.x, p.y-loadingShip.y, p.r, 0, Math.PI*2);
            ctx.fill();
        });

        // Vaisseau simplifié
        ctx.fillStyle = "#00d9ff";
        ctx.fillRect(-15, -20, 30, 40);
        ctx.fillStyle = "#fff";
        ctx.fillRect(-5, -25, 10, 5);
        
        ctx.restore();

    } else if (state === STATE.START_SCREEN) {
        drawText("ASTRO DODGE", GAME_WIDTH/2, 150, 40, "#00d9ff");
        drawText(`BIENVENUE, ${username}`, GAME_WIDTH/2, 250, 25, "#fff");
        drawText(`Meilleur Score: ${bestScore}`, GAME_WIDTH/2, 300, 20, "#ffde21");

        const isHovering = mouseInRect(110, 480, 200, 50);
        
        ctx.save();
        ctx.globalAlpha = startButtonAnim.alpha;
        
        drawButton("COMMENCER", 110, 480, 200, 50, 25, "#1de9b6", isHovering);
        
        // Effet de pulsation
        ctx.globalAlpha = startButtonAnim.alpha * 0.5 * (1 + Math.sin(startButtonAnim.pulse*3)/2);
        ctx.shadowColor = "#1de9b6";
        ctx.shadowBlur = 40;
        drawRoundedRect(110, 480, 200, 50, 25, false, true);
        
        ctx.restore();

    } else if(state === STATE.TAKEOFF || state === STATE.LANDING){
        drawPlayer(player);
        asteroids.forEach(drawAsteroid);
        coins.forEach(drawCoin);

        // Terre
        ctx.save();
        ctx.translate(GAME_WIDTH/2, earthY);
        ctx.scale(1 + launchProgress * 0.5, 1 + launchProgress * 0.5);

        ctx.fillStyle = "#000080";
        ctx.beginPath();
        ctx.arc(0, 0, 400, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#00aa00";
        ctx.beginPath();
        ctx.arc(0, 0, 380, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#00d9ff";
        ctx.beginPath();
        ctx.arc(0, 0, 350, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();

        // Texte de transition
        if (state === STATE.TAKEOFF) {
            drawText("DÉCOLLAGE", GAME_WIDTH/2, GAME_HEIGHT/2, 30, "#fff");
        } else {
            drawText("ATTERRISSAGE", GAME_WIDTH/2, GAME_HEIGHT/2, 30, "#fff");
        }

    } else if(state===STATE.MENU){
        drawText("ASTRO DODGE", GAME_WIDTH/2, 120, 40, "#00d9ff");
        drawText(`CRÉDITS: ${credits}`, GAME_WIDTH/2, 190, 20, "#ffde21");
        
        const isHoverPlay = mouseInRect(110, 240, 200, 50);
        const isHoverShop = mouseInRect(110, 310, 200, 50);
        
        drawButton("JOUER", 110, 240, 200, 50, 15, "#1de9b6", isHoverPlay);
        drawButton("MAGASIN", 110, 310, 200, 50, 15, "#00d9ff", isHoverShop);
        
        // Décalage des boutons si on est sur mobile
        const yLeaderboard = isMobile ? 380 : 450;
        const yQuit = isMobile ? 450 : 520;

        const isHoverLeaderboard = mouseInRect(110, yLeaderboard, 200, 50);
        const isHoverQuit = mouseInRect(110, yQuit, 200, 50);

        // BOUTON OPTIONS (Desktop Only)
        if (!isMobile) {
            const isHoverOptions = mouseInRect(110, 380, 200, 50);
            drawButton("OPTIONS", 110, 380, 200, 50, 15, "#ff3300", isHoverOptions);
        }
        
        drawButton("CLASSEMENT", 110, yLeaderboard, 200, 50, 15, "#ffeb3b", isHoverLeaderboard);
        drawButton("QUITTER", 110, yQuit, 200, 50, 15, "#ff00ea", isHoverQuit);

    } else if(state===STATE.OPTIONS){
        drawText("OPTIONS", GAME_WIDTH/2, 120, 40, "#00d9ff");

        // Bouton de contrôle
        const isHoverControl = mouseInRect(110, 240, 200, 50);
        const controlText = `Contrôle: ${controlMode}`;
        drawButton(controlText, 110, 240, 200, 50, 15, "#1de9b6", isHoverControl);
        drawText(controlMode === 'Fleche' ? "Utilisez les flèches" : "Suivez le curseur", GAME_WIDTH/2, 280, 14, "#aaa");

        // Bouton de retour
        const isHoverBack = mouseInRect(110, 540, 200, 50);
        drawButton("RETOUR", 110, 540, 200, 50, 15, "#ff00ea", isHoverBack);

    } else if(state===STATE.SHOP){
        drawText("MAGASIN SPATIAL", GAME_WIDTH/2, 50, 30, "#00d9ff");
        drawText(`CRÉDITS: ${credits}`, GAME_WIDTH/2, 100, 20, "#ffde21");

        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 120, GAME_WIDTH, GAME_HEIGHT - 120 - 100);
        ctx.clip();
        
        ships.forEach((s,i)=>{
            const cardY=140+i*160 - shopScroll;
            const isSelected = i===player.type;
            const isHover = mouseInRect(40, cardY, 340, 140);

            let cardColor = "#333";
            let actionText = "";
            let textColor = "#fff";

            if(isSelected){
                cardColor = "#00d9ff";
                actionText = "ÉQUIPÉ";
            } else if(s.unlocked){
                cardColor = "#1de9b6";
                actionText = "SÉLECTIONNER";
            } else if(credits>=s.cost){
                cardColor = "#ffde21";
                actionText = `${s.cost} CRÉDITS`;
                textColor = "#000";
            } else {
                cardColor = "#ff00ea";
                actionText = `${s.cost} CRÉDITS`;
            }

            // Carte
            ctx.save();
            ctx.shadowColor = cardColor;
            ctx.shadowBlur = isHover ? 30 : 10;
            ctx.fillStyle = "rgba(0,0,0,0.4)";
            ctx.strokeStyle = cardColor;
            ctx.lineWidth = 3;
            drawRoundedRect(40, cardY, 340, 140, 15, true, true);

            // Vaisseau (Simplified Draw)
            ctx.translate(80, cardY+70);
            ctx.rotate(-Math.PI/6);
            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-15, 15);
            ctx.lineTo(15, 15);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = s.cockpit;
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();


            // Infos
            drawText(s.name, 220, cardY+30, 22, cardColor);
            drawText(`Vitesse: ${s.speed} | Bonus: ${s.bonus}`, 220, cardY+60, 14, "#aaa");
            drawText(s.desc, 220, cardY+85, 12, "#777");

            // Action Button
            ctx.save();
            ctx.fillStyle = cardColor;
            ctx.strokeStyle = isSelected || s.unlocked ? cardColor : "#000";
            ctx.lineWidth = 2;
            
            drawRoundedRect(280, cardY+105, 80, 25, 10, true, !isSelected);
            drawText(actionText, 320, cardY+118, 14, textColor);
            ctx.restore();
        });

        ctx.restore();

        // Bouton de retour
        const isHoverBack = mouseInRect(110, 540, 200, 50);
        drawButton("RETOUR", 110, 540, 200, 50, 15, "#ff00ea", isHoverBack);

    } else if(state===STATE.LEADERBOARD){
        drawText("CLASSEMENT", GAME_WIDTH/2, 50, 30, "#00d9ff");

        // En-têtes du tableau
        drawText("RANG", 70, 110, 16, "#1de9b6", "left");
        drawText("JOUEUR", 180, 110, 16, "#1de9b6", "left");
        drawText("SCORE", 340, 110, 16, "#1de9b6", "left");

        // Lignes du tableau
        leaderboardData.forEach((entry, i)=>{
            const y = 150 + i * 40;
            const rank = i + 1;
            const isPlayer = entry.name === "Vous";

            let color = isPlayer ? "#ffde21" : "#fff";
            if (rank <= 3) color = ["#ffd700", "#c0c0c0", "#cd7f32"][i]; // Or, Argent, Bronze

            drawText(rank + (i < 5 ? '.' : ''), 70, y, 18, color, "left");
            drawText(entry.name, 180, y, 18, color, "left");
            drawText(entry.score, 340, y, 18, color, "left");

            if (isPlayer) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.strokeRect(40, y - 20, GAME_WIDTH - 80, 40);
            }
        });

        // Bouton de retour
        const isHoverBack = mouseInRect(110, 540, 200, 50);
        drawButton("RETOUR", 110, 540, 200, 50, 15, "#ff00ea", isHoverBack);

    } else if(state===STATE.PLAY || state===STATE.GAMEOVER){
        // Dessin des éléments du jeu
        asteroids.forEach(drawAsteroid);
        coins.forEach(drawCoin);
        if(state!==STATE.GAMEOVER || explosion===null) drawPlayer(player);
        if(explosion){
            ctx.fillStyle = `rgba(255, 100, 0, ${explosion.alpha})`;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, explosion.r, 0, Math.PI*2);
            ctx.fill();
        }
        
        // Affichage du choc de mort (glitch)
        if(deathShockwave.active){
            ctx.save();
            ctx.strokeStyle = `rgba(0, 217, 255, ${deathShockwave.alpha})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(deathShockwave.x, deathShockwave.y, deathShockwave.r, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        if(glitchTimer > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${glitchTimer/30})`;
            ctx.fillRect(Math.random()*10-5, Math.random()*10-5, GAME_WIDTH, GAME_HEIGHT);
        }

        // HUD Score et Vie
        const levelColor = levelColors[colorIndex];
        drawText(`LEVEL ${currentLevel}`, GAME_WIDTH/2, 30, 25, levelColor);
        drawText(`SCORE: ${Math.floor(score)}`, GAME_WIDTH/2, 60, 18, "#fff");
        drawText(`MEILLEUR: ${bestScore}`, 310, 30, 14, "#ffde21");
        drawText(`CRÉDITS: ${credits}`, 110, 30, 14, "#ffde21");
        
        // Indicateur de Vie
        drawText(`VIE: ${player.life}`, 110, 60, 18, player.life > 1 ? "#00ff88" : "#fff");

        // Affichage des textes flottants
        floatingTexts.forEach(t => drawText(t.text, t.x, t.y, 14, t.color));

        // Animation de niveau
        if(levelAnimTimer > 0) {
            ctx.save();
            ctx.globalAlpha = levelAnimTimer / 100;
            ctx.fillStyle = levelColor;
            ctx.fillRect(0, GAME_HEIGHT/2 - 25, GAME_WIDTH, 50);
            drawText(`NIVEAU ${currentLevel} ATTEINT!`, GAME_WIDTH/2, GAME_HEIGHT/2, 30, "#0a0e27");
            ctx.restore();
        }

        // Affichage Game Over
        if(state===STATE.GAMEOVER && flashAlpha <= 0.1){
            drawText("GAME OVER", GAME_WIDTH/2, GAME_HEIGHT/2 - 80, 50, "#ff3300");
            drawText(`SCORE FINAL: ${Math.floor(score)}`, GAME_WIDTH/2, GAME_HEIGHT/2, 25, "#fff");
            drawText("TOUCHER L'ÉCRAN POUR CONTINUER", GAME_WIDTH/2, GAME_HEIGHT/2 + 50, 15, "#aaa");
        }
    }

    // Flash d'écran (dégâts/nouveau niveau)
    if(flashAlpha > 0){
        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }
    // Flash de crédit
    if(coinFlashAlpha > 0){
        ctx.fillStyle = `rgba(255, 222, 33, ${coinFlashAlpha/2})`;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }

    // Transition d'état (fondu noir)
    if(transition.active) {
        ctx.fillStyle = `rgba(0, 0, 0, ${transition.nextState !== null ? transition.alpha : 1-transition.alpha})`;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }

    requestAnimationFrame(draw);
}

loadGameData();
setInterval(update, 1000/60);
requestAnimationFrame(draw); 
</script>
</body>
</html>