<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Stickman Runner</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* --- STYLES GLOBALES & RESPONSIVE --- */
        body {
            margin: 0;
            background-color: #0d1b2a; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw; 
            overflow: hidden;
            font-family: 'Orbitron', sans-serif; 
            color: #E0E0E0; 
            position: relative; 
        }

        /* --- STYLES DES BARRES DE D√âFILEMENT (CYBER NEON) --- */
        /* Appliqu√© √† tous les √©l√©ments scrollables */
        body::-webkit-scrollbar, 
        #gradeShop::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        body::-webkit-scrollbar-track,
        #gradeShop::-webkit-scrollbar-track {
            background: #0d1b2a; /* Dark background */
            border-radius: 10px;
        }

        body::-webkit-scrollbar-thumb,
        #gradeShop::-webkit-scrollbar-thumb {
            background: #00FFC0; /* Neon thumb color */
            border-radius: 10px;
            box-shadow: 0 0 5px #00FFC0;
        }

        body::-webkit-scrollbar-thumb:hover,
        #gradeShop::-webkit-scrollbar-thumb:hover {
            background: #33ffcc; /* Lighter on hover */
        }
        
        /* Conteneur principal pour le jeu et les menus */
        #gameWrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px; 
            max-height: 600px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- CANVAS (maintenant responsive) --- */
        canvas {
            width: 100%;
            height: 100%;
            border: 4px solid #FF6B6B; 
            background-color: #1a2a3a; 
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5); 
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            aspect-ratio: 4 / 3; 
            margin: auto;
            transition: border-color 0.1s, box-shadow 0.1s;
        }
        
        /* --- HOTBAR (Barre du haut) --- */
        #topHotbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            background-color: #0d1b2a;
            padding: 10px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-bottom: 2px solid #FF6B6B; 
            z-index: 100; 
            font-size: 0.8em; 
            transition: border-color 0.1s;
        }
        .hotbar-item {
            display: block; 
            text-align: center;
        }
        .hotbar-label {
            display: block;
            font-size: 1em;
            color: #aaa;
        }
        .hotbar-value {
            font-weight: bold;
            color: #00FFC0; 
            display: block;
            margin-top: 2px;
            font-size: 1.2em;
            transition: color 0.1s;
        }

        /* --- SCORE EN JEU (Num√©ro uniquement, tr√®s gros, centr√©) --- */
        #scoreDisplay {
            position: absolute; 
            top: 25%; 
            left: 50%;
            transform: translate(-50%, 0) scaleY(1.3); 
            
            font-size: 5.5vw; 
            
            color: #2c3e50; 
            z-index: 90; 
            text-shadow: 0 0 10px rgba(44, 62, 80, 0.9); 
            display: none;
            font-family: 'Orbitron', sans-serif; 
            line-height: 1; 
            font-weight: 900;
        }

        /* --- √âCRANS GLOBAUX (REMISE √Ä 350px) --- */
        #menuContainer, #pauseMenu, #gameOverScreen, #loadingScreen, #rankingScreen, #tutorialScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50; 
            max-width: 90%; 
            width: 350px; /* Taille par d√©faut */
        }
        
        /* STYLES COMMUNS DES √âCRANS DE MENU */
        #loadingScreen, #menuScreen, #gradeShop, #rankingScreen, #gameOverScreen, #pauseMenu, #tutorialScreen {
            background-color: #1a2a3a; 
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.9), 0 0 10px #FF6B6B; 
            border: 2px solid #FF6B6B; 
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            max-height: 90vh; 
            overflow-y: auto; 
        }

        /* --- STYLES SP√âCIFIQUES DU SHOP/AM√âLIORATION (ISOL√â ET PLUS LARGE) --- */
        #gradeShop {
            width: 450px; /* Taille augment√©e sp√©cifiquement pour le shop */
            max-width: 90%; 
            gap: 15px; 
        }
        
        /* --- STYLES DES BOUTONS D'ACTION --- */
        .menu-button {
            display: block;
            width: 80%; 
            padding: 12px;
            margin: 10px auto;
            background-color: #00FFC0; 
            color: black; 
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .menu-button:hover {
            background-color: #33ffcc; 
            box-shadow: 0 0 10px #00FFC0; 
        }
        
        #upgradeButton {
            background-color: #00BFFF; 
            width: 90%;
            font-size: 1.2em;
            padding: 15px;
            margin-top: 20px;
            white-space: normal; 
            height: auto;
            color: white; 
        }
        #upgradeButton:hover {
            background-color: #19cfff;
            box-shadow: 0 0 15px #00BFFF;
        }
        #upgradeButton:disabled {
            background-color: #4a4a6e;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* --- CLASSEMENT --- */
        #rankingTable {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }
        #rankingTable th, #rankingTable td {
            padding: 8px;
            border: 1px solid #FF6B6B30;
            text-align: left;
            font-size: 0.9em;
        }
        #rankingTable th {
            background-color: #FF6B6B20;
            color: #FF6B6B;
            font-weight: bold;
        }
        #rankingTable tbody tr:nth-child(1) { background-color: #FFD70030; font-weight: bold; color: gold; }
        #rankingTable tbody tr:nth-child(2) { background-color: #C0C0C030; }
        #rankingTable tbody tr:nth-child(3) { background-color: #CD7F3230; }
        .rank-grade {
            font-size: 1.2em;
        }
        
        /* --- NOUVEAU: SPINNER DE CHARGEMENT --- */
        .spinner {
            border: 4px solid rgba(0, 255, 192, 0.1); 
            border-top: 4px solid #00FFC0; 
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="loadingScreen">
            <h1>STICKMAN RUNNER</h1>
            <div class="spinner"></div> 
            <p id="loadingMessage">Chargement des donn√©es...</p>
            <span style="color: #00FFC0;">INITIALISATION DU JEU...</span>
        </div>

        <div id="scoreDisplay">0</div>
        
        <div id="tutorialScreen" style="display: none;">
            <h2>TUTORIEL</h2>
            <p style="font-size: 1.1em; color: #00FFC0; margin-bottom: 20px;">Apprenez les commandes de base pour survivre dans le Cyber Espace !</p>
            
            <hr style="width: 70%; border-color: #00FFC0; margin: 15px 0;">

            <p style="text-align: left; width: 100%; max-width: 300px; margin: 0 auto 10px auto;">
                <span style="font-weight: bold; color: #FF6B6B;">SAUTER :</span> Appuyez sur **ESPACE** (ou Clic Gauche)<br>
                <span style="font-weight: bold; color: #FF6B6B;">CHUTE RAPIDE :</span> Rel√¢chez **ESPACE** (ou Clic Gauche)<br>
                <span style="font-weight: bold; color: #FF6B6B;">PAUSE :</span> Appuyez sur **P** ou **√âCHAP**
            </p>
            
            <hr style="width: 70%; border-color: #00FFC0; margin: 15px 0;">

            <p style="max-width: 300px;">Le joueur avance automatiquement. Votre objectif est de **sauter** sur les plateformes pour √©viter la chute et d'utiliser la **chute rapide** pour atterrir plus vite.</p>

            <button class="menu-button" id="startMenuButton" style="background-color: #00BFFF; margin-top: 20px;">
                COMPRIS, ENTRER DANS LE MENU
            </button>
        </div>


        <div id="menuContainer" style="display: none;">
            <div id="menuScreen">
                <h1>Stickman Runner</h1>
                <p>Bienvenue, <span id="currentUsernameDisplay" style="color:#00FFC0;"></span></p>
                <button class="menu-button" id="playButton">JOUER</button>
                <button class="menu-button" id="gradesButton">AM√âLIORATION (GRADES)</button>
                <button class="menu-button" id="rankingButton">CLASSEMENT</button>
                <button class="menu-button" id="quitGameButton" style="background-color: #FF6B6B;">QUITTER LE JEU</button>
                </div>

            <div id="gradeShop" style="display: none;">
                <h2>Am√©lioration de Grade</h2>
                <p style="font-size: 1.2em;">Argent : <span id="moneyInShop" style="color: gold; font-weight: bold;">0</span> <span style="color: gold; font-weight: bold;">$</span></p>
                
                <hr style="width: 80%; border-color: #FF6B6B; margin: 15px 0;"> 
                
                <p style="font-size: 1.1em; color: #E0E0E0;">Grade Actuel : <span id="currentGradeDisplay" style="font-weight: bold; color: #00FFC0;">Poussi√®re (‚ö™)</span></p> 
                <button class="menu-button" id="upgradeButton">ACHETER : [Grade Suivant] - 50 $</button>
                
                <button class="menu-button" id="backButton" style="margin-top: 15px;">RETOUR</button>
            </div>
        </div>
        
        <div id="pauseMenu" style="display: none;">
            <h2>PAUSE</h2>
            <p id="pauseCurrentScore" style="font-size: 1.5em; color: #FF6B6B; margin-bottom: 20px;">Score: 0</p> 
            <button class="menu-button" id="continueButton">CONTINUER</button>
            <button class="menu-button" id="quitButton">QUITTER</button> 
        </div>

        <div id="gameOverScreen" style="display: none;">
            <h2>GAME OVER</h2>
            <p style="color: yellow; font-size: 1.2em;">Sauvegarde des donn√©es...</p>
            <p>Meilleur Score: <span id="finalHighScore" class="final-stat">0</span></p>
            <p>Score Final: <span id="finalCurrentScore" class="final-stat">0</span></p>
            <p>Argent Total: <span id="finalTotalMoney" class="final-stat">0</span> <span style="color: gold;">$</span></p>
            <button class="menu-button" id="restartButton">REJOUER</button>
            <button class="menu-button" id="goToMenuButton" style="background-color: #4a4a6e;">MENU PRINCIPAL</button>
        </div>

        <div id="rankingScreen" style="display: none;">
            <h2>CLASSEMENT TOP 3</h2>
            <table id="rankingTable">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Grade</th>
                        <th>Joueur</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="rankingTableBody">
                    <tr><td colspan="4">Chargement...</td></tr>
                </tbody>
            </table>
            <button class="menu-button" id="backToMenuFromRanking">RETOUR</button>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="topHotbar" style="display: none;">
        <div class="hotbar-item">
            <span id="label1" class="hotbar-label">Meilleur Score:</span>
            <span id="value1" class="hotbar-value">0</span>
        </div>
        <div class="hotbar-item" id="currentScoreHotbarItem"> 
            <span id="label2" class="hotbar-label">Score Pr√©c√©dent:</span>
            <span id="value2" class="hotbar-value">0</span>
        </div>
        <div class="hotbar-item">
            <span id="label3" class="hotbar-label">Argent Total:</span>
            <span id="value3" class="hotbar-value">0</span> <span style="color: gold; font-weight: bold;">$</span>
        </div>
    </div>

    <script>
        // --- CONFIGURATION DU SERVEUR ---
        const SERVER_URL = 'https://project-3-api-2bgb.onrender.com'; 
        const API_BASE = '/stickman_runner';
        const RELOAD_INTERVAL_MS = 5000; // 5 secondes

        // --- CONFIGURATION DU JEU (TAILLES DE R√âF√âRENCE) ---
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 600;

        function scaleX(x) { return (x / BASE_WIDTH) * canvas.width; }
        function scaleY(y) { return (y / BASE_HEIGHT) * canvas.height; }
        function scaleSize(s) { return (s / BASE_WIDTH) * canvas.width; }

        // --- CONFIGURATION AUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let audioInitialized = false;

        function initializeAudio() {
            if (!audioInitialized) {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume().then(() => {
                        audioInitialized = true;
                    }).catch(e => console.error("Could not resume audio context:", e));
                } else {
                     audioInitialized = true;
                }
            }
        }
        document.addEventListener('click', initializeAudio, { once: true });
        document.addEventListener('keydown', initializeAudio, { once: true });

        function createTone(freq, duration, type, volume = 0.5) {
            if (!audioInitialized) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        const sfx = {
            jump: () => createTone(500, 0.1, 'square'),
            fastFall: () => createTone(200, 0.05, 'triangle'),
            land: () => createTone(350, 0.08, 'sine', 0.4), 
            death: () => {
                createTone(150, 0.5, 'sawtooth', 0.8);
                createTone(100, 0.5, 'square', 0.8);
            },
            money: () => {
                createTone(600, 0.05, 'sine', 0.3);
                setTimeout(() => createTone(800, 0.05, 'sine', 0.3), 50);
            },
            restart: () => createTone(300, 0.1, 'square'),
            upgrade: () => { 
                createTone(1000, 0.05, 'sine'); 
                setTimeout(() => createTone(1200, 0.05, 'sine'), 50); 
            }
        };
        
        // --- CONFIGURATION DU JEU ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // √âl√©ments du DOM (mis en cache pour la performance)
        const menuContainer = document.getElementById('menuContainer');
        const canvasElement = document.getElementById('gameCanvas');
        const pauseMenuElement = document.getElementById('pauseMenu');
        const gameOverScreenElement = document.getElementById('gameOverScreen');
        const topHotbarElement = document.getElementById('topHotbar');
        const loadingScreenElement = document.getElementById('loadingScreen');
        const tutorialScreenElement = document.getElementById('tutorialScreen'); // NOUVELLE LIGNE
        const rankingScreenElement = document.getElementById('rankingScreen'); 
        const loadingMessageElement = document.getElementById('loadingMessage');
        const currentScoreHotbarItem = document.getElementById('currentScoreHotbarItem');
        const scoreDisplayElement = document.getElementById('scoreDisplay');

        const GAME_STATE = { LOADING: -1, TUTORIAL: -0.5, MENU: 0, PLAYING: 1, GRADES: 2, GAMEOVER: 3, PAUSED: 4, RANKING: 5 };
        let currentState = GAME_STATE.LOADING; 

        // Vitesse initiale
        let initialPlayerColor = '#00FFC0'; 
        let currentMaxSpeed = 4; 
        
        let MAX_SPEED_CAP_BASE = 50; 
        // Vitesse d'augmentation r√©duite (0.01 / 1.5)
        let MAX_SPEED_CAP = 50; 
        
        const SPEED_INCREASE_RATE = 0.005; 
        
        const GRAVITY = 0.35;         
        const JUMP_VELOCITY = -10.5;  
        const FAST_FALL_VELOCITY = 10; 
        const COYOTE_TIME_MAX = 6; 
        const COLLISION_BUFFER_V = 5;  
        const COLLISION_BUFFER_H = 10; 
        const JUMP_ROTATION = Math.PI / 4; 

        let lastMoneyScoreThreshold = 0; 
        const MONEY_GAIN_PER_THRESHOLD = 10; 

        // Constantes bas√©es sur les valeurs de r√©f√©rence
        const START_PLATFORM_REF = { x: 0, y: BASE_HEIGHT - 50, width: BASE_WIDTH, height: 50 }; 
        const GROUND_LEVEL_REF = BASE_HEIGHT - 20; 
        const CAMERA_CENTER_X_REF = BASE_WIDTH / 3; 
        
        let isSpacePressed = false;
        let ignoreNextSpaceUp = false; 
        
        // --- DONN√âES DU JOUEUR (Chargement du pseudo depuis localStorage) ---
        let username = localStorage.getItem('username') || 'Invit√© Cyber'; 
        let currentGradeName = "Poussi√®re"; 
        
        // --- SYST√àME DE GRADES ---
        const GRADES = [
            { id: 1, name: "Poussi√®re", cost: 0, symbol: "‚ö™", speedBonus: 0, color: '#E0E0E0' }, 
            { id: 2, name: "N. S√©l√©nium", cost: 50, symbol: "üü¢", speedBonus: 0, color: '#00FFC0' }, 
            { id: 3, name: "N. Mercure", cost: 150, symbol: "üîµ", speedBonus: 0, color: '#00BFFF' }, 
            { id: 4, name: "N. V√©nus", cost: 300, symbol: "üü£", speedBonus: 0, color: '#FF00FF' }, 
            { id: 5, name: "N. Terre", cost: 500, symbol: "‚ú®", speedBonus: 0, color: '#FFD700' }, 
            { id: 6, name: "N. Mars", cost: 800, symbol: "‚ö°", speedBonus: 0, color: '#FF6B6B' }, 
            { id: 7, name: "N. Jupiter", cost: 1200, symbol: "ü™ê", speedBonus: 0, color: '#FFA500' },
            { id: 8, name: "N. Saturne", cost: 1800, symbol: "üöÄ", speedBonus: 0, color: '#00FA9A' },
            { id: 9, name: "N. Uranus", cost: 2600, symbol: "üåå", speedBonus: 0, color: '#9932CC' },
            { id: 10, name: "MAX", cost: 5000, symbol: "üî•", speedBonus: 0, color: '#FF4500' } 
        ];
        
        let currentGradeId = 1;
        let money = 0;

        /**
         * CORRECTION: La fonction ne doit pas retourner GRADES[0] par d√©faut
         * si l'ID n'est pas trouv√© (comme l'ID 11), car cela cause une boucle
         * d'achat infinie de 'Poussi√®re'.
         */
        function getGrade(id) {
            return GRADES.find(g => g.id === id); 
        }

        function getGradeByName(name) {
             return GRADES.find(g => g.name === name) || GRADES[0];
        }

        function getNextGrade() {
            return getGrade(currentGradeId + 1);
        }
        
        function applyGradeStats() {
            MAX_SPEED_CAP = MAX_SPEED_CAP_BASE; 
            currentGradeName = getGrade(currentGradeId).name;
        }

        // --- GESTION DU SCORE ET DU STOCKAGE LOCAL (pour l'affichage en attente de serveur) ---
        let currentScore = 0;
        let highScore = 0; 
        let previousScore = 0;
        let lastDisplayedScore = 0; 
        
        function updateScore(amount) {
            currentScore += amount;
            
            const floorScore = Math.floor(currentScore);

            if (floorScore !== lastDisplayedScore) {
                scoreDisplayElement.textContent = `${floorScore}`;
                lastDisplayedScore = floorScore;
            }
            
            const currentMoneyThreshold = Math.floor(currentScore / 1000) * 1000;
            if (currentMoneyThreshold > lastMoneyScoreThreshold) {
                lastMoneyScoreThreshold = currentMoneyThreshold;
                money += MONEY_GAIN_PER_THRESHOLD; 
                sfx.money();
            }
        }
        
        function updateHighScoreAndMoney() {
            const roundedCurrentScore = Math.floor(currentScore);
            previousScore = roundedCurrentScore;

            if (roundedCurrentScore > highScore) {
                highScore = roundedCurrentScore;
            }
            
            // On sauvegarde d√®s qu'un match est termin√©
            saveGameData(); 
            updateHotbarDisplay(); 
        }
        
        function updateHotbarDisplay() {
            document.getElementById('value1').textContent = Math.floor(highScore);
            document.getElementById('value3').textContent = Math.floor(money);
            document.getElementById('currentUsernameDisplay').textContent = username;
            
            if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.PAUSED) {
                currentScoreHotbarItem.style.display = 'none'; 
            } else { 
                currentScoreHotbarItem.style.display = 'block'; 
                document.getElementById('value2').textContent = Math.floor(previousScore);
                updateUpgradeShopDisplay(); 
            }
        }

        // --- API & COMMUNICATION SERVEUR ---

        async function saveGameData() {
            const gradeName = getGrade(currentGradeId).name;

            const dataToSave = {
                username: username,
                best_score: Math.floor(highScore),
                credit: Math.floor(money),
                grade: gradeName
            };

            console.log("Sauvegarde des donn√©es:", dataToSave);

            try {
                const response = await fetch(`${SERVER_URL}/stickman_runner_update_data`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(dataToSave),
                });

                const result = await response.json();
                console.log("R√©ponse du serveur (Sauvegarde):", result);

                if (result.status === "error") {
                     console.error("Erreur de sauvegarde: " + result.message);
                }

            } catch (error) {
                console.error("Erreur de communication avec le serveur (Sauvegarde):", error);
            }
        }

        async function loadGameData() {
            hideAllScreens();
            currentState = GAME_STATE.LOADING;
            loadingScreenElement.style.display = 'flex';
            loadingMessageElement.textContent = `Connexion au serveur et chargement des donn√©es de ${username}...`;

            try {
                const response = await fetch(`${SERVER_URL}/stickman_runner_get_data`, {
                    method: 'POST',
                    headers: {
                        // Obligatoire pour envoyer du JSON
                        'Content-Type': 'application/json' 
                    },
                    body: JSON.stringify({
                        // La cl√© 'username' est celle attendue par votre route Flask
                        'username': username 
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status} (${response.statusText || 'M√©thode non autoris√©e (405)'})`);
                }
                
                const result = await response.json();
                console.log("R√©ponse du serveur (Chargement):", result);
                
                let loadedData;

                if (result.status === "success" || result.status === "not_found") {
                    loadedData = result.data;
                    
                    // Appliquer les donn√©es
                    highScore = loadedData.distance || 0;
                    money = loadedData.credit || 0;
                    
                    const loadedGrade = getGradeByName(loadedData.grade) || GRADES[0];
                    currentGradeId = loadedGrade.id;

                    applyGradeStats();
                    updateHotbarDisplay(); 

                    showTutorial(); // NOUVEL APPEL : Tutoriel apr√®s chargement.
                } else {
                    // Si le serveur r√©pond en JSON mais indique une erreur logique
                    console.error("Erreur de chargement: " + result.message);
                    loadingMessageElement.textContent = `Erreur de chargement des donn√©es: ${result.message}. Nouvelle tentative dans ${RELOAD_INTERVAL_MS / 1000} secondes.`;
                    setTimeout(loadGameData, RELOAD_INTERVAL_MS);
                }

            } catch (error) {
                console.error("Erreur de communication avec le serveur (Chargement):", error);
                
                // RESTER EN √âCRAN DE CHARGEMENT EN CAS D'ERREUR
                loadingMessageElement.textContent = `Serveur injoignable ou erreur de connexion. Nouvelle tentative dans ${RELOAD_INTERVAL_MS / 1000} secondes.`;
                
                // Fallback des stats
                highScore = 0;
                money = 0;
                currentGradeId = 1;
                applyGradeStats();
                updateHotbarDisplay();
                
                // On relance la fonction de chargement apr√®s un d√©lai
                setTimeout(loadGameData, RELOAD_INTERVAL_MS);
            }
        }
        let leaderboardData = [];
        async function fetchLeaderboard() {
            const rankingTableBody = document.getElementById('rankingTableBody');
            rankingTableBody.innerHTML = '<tr><td colspan="4">Chargement...</td></tr>'; // Message de chargement initial
            
            // NOTE: Pour √©viter l'erreur de r√©f√©rence lors du mappage, on utilise 'highScore' stock√© localement ou charg√©
            const bestScore = Math.floor(highScore); 

            try {
                const response = await fetch(`${SERVER_URL}/stickman_runner_get_leaderboard`, {
                    method: 'GET'
                }); 
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP! Statut: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.status === "success") {
                    const leaderboardRawData = result.data; 

                    if (!Array.isArray(leaderboardRawData)) {
                        console.error("Erreur de format de donn√©es: 'data' n'est pas un tableau.", result);
                        leaderboardData = [];
                        // Affichage de l'erreur
                        rankingTableBody.innerHTML = '<tr><td colspan="4">Erreur de donn√©es.</td></tr>';
                        return;
                    }

                    // 1. Mappage robuste et filtration des scores √† 0
                    leaderboardData = leaderboardRawData
                        // FILTRE : Supprimer les entr√©es avec un score de 0
                        .filter(e => Number(e.distance) > 0)
                        .map(e => {
                            // CORRECTION : L'API renvoie le nom sous la cl√© 'name' (Python)
                            const remoteUsername = e.name && e.name.trim() !== '' ? e.name : 'Joueur Inconnu';
                            // GESTION : Le grade est manquant, on force au grade de base
                            const gradeName = e.grade && e.grade.trim() !== '' ? e.grade : GRADES[0].name; 

                            return {
                                name: (remoteUsername === username ? "Vous" : remoteUsername), 
                                score: Number(e.distance), 
                                grade: gradeName // Sera 'Poussi√®re' par d√©faut ou le grade s'il √©tait pr√©sent
                            };
                        })
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 5); 
                    
                    // 2. Ajout du score de l'utilisateur s'il n'est pas dans le Top 5 (inchang√©)
                    if (!leaderboardData.some(e => e.name === "Vous")) {
                        const userGrade = getGrade(currentGradeId); 
                        leaderboardData.push({ 
                            name: "Vous", 
                            score: bestScore, 
                            grade: userGrade.name 
                        }); 
                        leaderboardData.sort((a, b) => b.score - a.score);
                    }
                    
                    // 3. MISE √Ä JOUR DE L'AFFICHAGE DU TABLEAU
                    let htmlContent = '';
                    leaderboardData.forEach((entry, index) => {
                        const gradeInfo = getGradeByName(entry.grade); // La fonction est maintenant r√©siliente
                        const gradeSymbol = gradeInfo.symbol; 
                        
                        htmlContent += `
                            <tr>
                                <td>${index + 1}</td>
                                <td class="rank-grade" style="color:${gradeInfo.color};">${gradeSymbol} ${entry.grade}</td>
                                <td>${entry.name}</td>
                                <td>${Math.floor(entry.score)}</td>
                            </tr>
                        `;
                    });

                    rankingTableBody.innerHTML = htmlContent;

                } else {
                    console.error("Erreur de chargement du classement (Statut non conforme):", result.message);
                    rankingTableBody.innerHTML = '<tr><td colspan="4">√âchec de la r√©cup√©ration du classement.</td></tr>';
                }
            } catch (e) {
                console.error("Erreur de communication avec le serveur (Classement Stickman Runner):", e.message);
                rankingTableBody.innerHTML = '<tr><td colspan="4">Serveur injoignable.</td></tr>';
            }
        }
        function updateUpgradeShopDisplay() {
            document.getElementById('moneyInShop').textContent = Math.floor(money); 
            
            const currentGrade = getGrade(currentGradeId);
            const nextGrade = getNextGrade();

            document.getElementById('currentGradeDisplay').innerHTML = `${currentGrade.name} (${currentGrade.symbol})`; 
            
            // NOTE: L'√©l√©ment 'speedCapDisplay' n'existe plus dans le DOM, mais la variable MAX_SPEED_CAP est toujours mise √† jour dans applyGradeStats.
            // Si la ligne suivante √©tait encore pr√©sente dans le DOM, elle serait: document.getElementById('speedCapDisplay').textContent = MAX_SPEED_CAP.toFixed(1); 
            
            if (nextGrade) {
                document.getElementById('upgradeButton').textContent = `ACHETER : ${nextGrade.name} - ${nextGrade.cost} $`;
                document.getElementById('upgradeButton').disabled = money < nextGrade.cost;
            } else {
                document.getElementById('upgradeButton').textContent = "GRADE MAX ATTEINT";
                document.getElementById('upgradeButton').disabled = true;
            }
        }


        function handleUpgrade() {
            const nextGrade = getNextGrade();

            if (nextGrade) {
                const cost = nextGrade.cost;

                if (money >= cost) {
                    money -= cost;
                    currentGradeId = nextGrade.id;
                    applyGradeStats(); 
                    saveGameData(); 
                    sfx.upgrade();
                    updateHotbarDisplay(); 
                    updateUpgradeShopDisplay();
                    alert(`F√©licitations ! Vous avez atteint le grade ${nextGrade.name}.`);
                } else {
                    alert(`Argent insuffisant ! Il vous manque ${cost - money} $ pour atteindre le grade ${nextGrade.name}.`);
                }
            }
        }


        // --- OBJET JOUEUR ---
        const player = {
            x: START_PLATFORM_REF.x + START_PLATFORM_REF.width / 2, 
            y: START_PLATFORM_REF.y - 10,
            oldY: START_PLATFORM_REF.y - 10, 
            width: 20,
            height: 20,
            velX: 0,
            velY: 0,
            isGrounded: true, 
            coyoteTime: 0, 
            color: initialPlayerColor, 
            rotation: 0 
        };
        
        // --- MISE √Ä JOUR DE LA COULEUR DU JOUEUR/BORDURE ---
        function updatePlayerAndBorderColor(newColor) {
            player.color = newColor; 
            canvasElement.style.borderColor = newColor;
            canvasElement.style.boxShadow = `0 0 30px ${newColor}80`; 
            topHotbarElement.style.borderBottomColor = newColor;
            document.getElementById('value1').style.color = newColor;
            document.getElementById('value2').style.color = newColor;
        }


        // --- PLATEFORMES, DESSIN & PHYSIQUE ---
        let particles = [];
        
        function createLandingParticles(x, y, color) {
            const num = 10;
            for (let i = 0; i < num; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,    
                    vy: -Math.random() * 3 - 1,       
                    radius: Math.random() * 3 + 1,    
                    color: color, alpha: 1, life: 30 
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += GRAVITY * 0.5; 
                p.alpha -= 1 / p.life;
                p.life--;

                if (p.life <= 0 || p.alpha <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.alpha; 
                ctx.fillStyle = p.color;   
                ctx.beginPath();
                ctx.arc(scaleX(p.x) - scaleX(cameraX), scaleY(p.y), scaleSize(p.radius), 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
         
        let currentPlatforms = [];
        let nextPlatformX = 150; 
        const MIN_GAP = 100;
        const MAX_GAP = 250; 
        const MIN_WIDTH = 80;
        const MAX_WIDTH = 200;

        function getRandomNeonColor() {
            const NEON_COLORS = ['#FF6B6B', '#00FFC0', '#00BFFF', '#FFD700', '#FF00FF']; 
            return NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
        }
        
        function generateNewPlatform() {
            const lastPlatform = currentPlatforms[currentPlatforms.length - 1] || { x: START_PLATFORM_REF.x + START_PLATFORM_REF.width, y: START_PLATFORM_REF.y, width: START_PLATFORM_REF.width };
            
            const gap = MIN_GAP + Math.random() * (MAX_GAP - MIN_GAP);
            const newX = lastPlatform.x + lastPlatform.width + gap;
            
            const newWidth = MIN_WIDTH + Math.random() * (MAX_WIDTH - MIN_WIDTH);
            const newY = GROUND_LEVEL_REF - (50 + Math.random() * 50); 

            currentPlatforms.push({ 
                x: newX, 
                y: newY, 
                width: newWidth, 
                height: 20, 
                color: getRandomNeonColor(), 
                isSolid: false 
            }); 
            nextPlatformX = newX;
        }
        
        function prunePlatforms() {
            currentPlatforms = currentPlatforms.filter(platform => platform.x + platform.width > player.x - BASE_WIDTH);
        }

        function drawRoundedRect(x, y, width, height, radius, color, isSolid = true) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);

            ctx.closePath();
            
            ctx.shadowColor = color; 
            ctx.strokeStyle = color;
            ctx.lineWidth = scaleSize(2); 

            if (isSolid) {
                ctx.fillStyle = color;
                ctx.shadowBlur = scaleSize(10); 
                ctx.fill();
            } else {
                ctx.shadowBlur = scaleSize(5); 
                ctx.stroke();
            }
            ctx.shadowBlur = 0; 
        }

        function drawPlayer() {
            const playerScaledX = scaleX(player.x - cameraX); 
            const playerScaledY = scaleY(player.y);
            const playerScaledW = scaleSize(player.width);
            const playerScaledH = scaleSize(player.height);
            const centerX = playerScaledX;
            const centerY = playerScaledY;
            
            ctx.save();
            
            ctx.translate(centerX, centerY);
            ctx.rotate(player.rotation); 
            
            drawRoundedRect(-playerScaledW / 2, 
                            -playerScaledH / 2, 
                            playerScaledW, 
                            playerScaledH, 
                            scaleSize(5), 
                            player.color,
                            true); 
            
            ctx.restore();
        }

        function drawPlatforms() {
            const scaledGroundLevel = scaleY(GROUND_LEVEL_REF);
            ctx.fillStyle = '#0a1520'; 
            ctx.fillRect(0, scaledGroundLevel, canvas.width, canvas.height - scaledGroundLevel);

            ctx.strokeStyle = '#FF6B6B'; 
            ctx.lineWidth = scaleSize(2);
            ctx.beginPath();
            ctx.moveTo(0, scaledGroundLevel);
            ctx.lineTo(canvas.width, scaledGroundLevel);
            ctx.stroke();

            currentPlatforms.forEach(platform => {
                drawRoundedRect(
                    scaleX(platform.x - cameraX), 
                    scaleY(platform.y), 
                    scaleSize(platform.width), 
                    scaleSize(platform.height), 
                    scaleSize(8), 
                    platform.color, 
                    platform.isSolid 
                );
            });
        }
        
        let cameraX = 0;
        let isDead = false;

        function updateCamera() {
            const targetX = player.x - CAMERA_CENTER_X_REF;
            cameraX = (player.x > START_PLATFORM_REF.width / 2) ? targetX : 0;
        }

        function checkCollisionWithPlatforms() {
            let wasGrounded = player.isGrounded;
            player.isGrounded = false;
            
            if (player.y + player.height / 2 >= GROUND_LEVEL_REF) {
                 if (!isDead) { isDead = true; gameOver(); }
                 return; 
            }
            
            currentPlatforms.forEach(platform => {
                const horizontalOverlap = player.x + player.width / 2 > (platform.x - COLLISION_BUFFER_H) && player.x - player.width / 2 < (platform.x + platform.width + COLLISION_BUFFER_H);
                const wasAboveOrInVerticalBuffer = player.oldY + player.height / 2 <= (platform.y + COLLISION_BUFFER_V); 
                const isNowBelowPlatformLine = player.y + player.height / 2 > platform.y;

                if (horizontalOverlap && wasAboveOrInVerticalBuffer && isNowBelowPlatformLine && player.velY > 0) { 
                    player.y = platform.y - player.height / 2; 
                    player.velY = 0; 
                    player.isGrounded = true; 
                    player.coyoteTime = COYOTE_TIME_MAX; 
                    player.rotation = 0; 
                    
                    if (!wasGrounded) {
                         updateScore(5); 
                         sfx.land();
                         updatePlayerAndBorderColor(platform.color);
                         createLandingParticles(player.x, platform.y, platform.color);
                         platform.isSolid = true; 
                    }
                }
            });
            
            if (player.isGrounded) { player.velX = currentMaxSpeed; }
        }

        function updatePlayer() {
            if (currentState !== GAME_STATE.PLAYING || isDead) return;
            
            player.oldY = player.y; 
            
            if (currentMaxSpeed < MAX_SPEED_CAP) {
                currentMaxSpeed += SPEED_INCREASE_RATE; 
            }

            player.velX = currentMaxSpeed; 
            player.velY += GRAVITY;
            
            player.x += player.velX;
            player.y += player.velY;
            
            if (!player.isGrounded) {
                 player.coyoteTime = Math.max(0, player.coyoteTime - 1);
                 player.rotation += 0.05; 
            }
            
            checkCollisionWithPlatforms();
            updateScore(currentMaxSpeed * 0.1); 
            
            if (player.x > nextPlatformX - BASE_WIDTH / 2) {
                generateNewPlatform();
                prunePlatforms();
            }
            
            updateCamera();
        }
        
        function gameOver() {
            sfx.death();
            isDead = true; 
            player.velX = 0; player.velY = 0; player.rotation = 0;
            currentState = GAME_STATE.GAMEOVER;
            
            updateHighScoreAndMoney(); 

            document.getElementById('finalHighScore').textContent = Math.floor(highScore);
            document.getElementById('finalCurrentScore').textContent = Math.floor(currentScore);
            document.getElementById('finalTotalMoney').textContent = Math.floor(money);

            showGameOverScreen();
        }
        
        function jump() {
            if (currentState !== GAME_STATE.PLAYING) return;

            if (player.isGrounded || player.coyoteTime > 0) {
                sfx.jump(); 
                player.velY = JUMP_VELOCITY;
                player.isGrounded = false;
                player.coyoteTime = 0; 
                player.rotation = JUMP_ROTATION; 
                updateScore(1); 
            }
        }
        
        function fastFall() {
            if (currentState !== GAME_STATE.PLAYING) return;

            if (player.velY < FAST_FALL_VELOCITY) { 
                 sfx.fastFall(); 
                 player.velY = FAST_FALL_VELOCITY;
                 updateScore(2); 
            }
        }
        
        function resizeCanvas() {
            const wrapper = document.getElementById('gameWrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        

        // *** GESTION DES √âV√âNEMENTS CLAVIER ***
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                 e.preventDefault(); 
                // Permet de commencer le jeu depuis le menu ou l'√©cran de fin
                if (currentState === GAME_STATE.MENU || currentState === GAME_STATE.GAMEOVER) { 
                    startGame();
                    return; 
                }
                // Permet de passer le tutoriel
                if (currentState === GAME_STATE.TUTORIAL) { 
                    showMenu();
                    return; 
                }
                if (currentState === GAME_STATE.PLAYING && !isSpacePressed) {
                    jump();
                    isSpacePressed = true;
                }
            }
            
            if (e.code === 'KeyP' || e.code === 'Escape') { togglePause(); }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                if (ignoreNextSpaceUp) { ignoreNextSpaceUp = false; return; }
                if (currentState === GAME_STATE.PLAYING) {
                    isSpacePressed = false;
                    fastFall();
                }
            }
        });


        // --- BOUCLE PRINCIPALE DU JEU ---

        function gameLoop() {
            if (currentState === GAME_STATE.PLAYING) { updatePlayer(); }
            updateParticles(); 

            if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.PAUSED) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(0, 0); 
                drawPlatforms(); 
                drawPlayer();
                drawParticles(); 
                ctx.restore();

                if (currentState === GAME_STATE.PLAYING) { updateHotbarDisplay(); }
            }

            requestAnimationFrame(gameLoop);
        }

        // --- GESTION DES VUES ---
        
        function hideAllScreens() {
            menuContainer.style.display = 'none';
            canvasElement.style.display = 'none';
            document.getElementById('scoreDisplay').style.display = 'none';
            pauseMenuElement.style.display = 'none';
            gameOverScreenElement.style.display = 'none';
            topHotbarElement.style.display = 'none';
            loadingScreenElement.style.display = 'none';
            rankingScreenElement.style.display = 'none';
            tutorialScreenElement.style.display = 'none'; // NOUVELLE LIGNE
        }

        function showTutorial() {
            hideAllScreens();
            currentState = GAME_STATE.TUTORIAL;
            tutorialScreenElement.style.display = 'flex';
        }

        function showMenu() {
            hideAllScreens();
            currentState = GAME_STATE.MENU;
            menuContainer.style.display = 'block';
            document.getElementById('menuScreen').style.display = 'flex'; 
            document.getElementById('gradeShop').style.display = 'none';
            rankingScreenElement.style.display = 'none';
            topHotbarElement.style.display = 'flex'; 
            updateHotbarDisplay(); 
        }

        function startGame() {
            if (currentState === GAME_STATE.LOADING) return; 

            sfx.restart();
            hideAllScreens();
            currentState = GAME_STATE.PLAYING;
            canvasElement.style.display = 'block';
            document.getElementById('scoreDisplay').style.display = 'block';
            topHotbarElement.style.display = 'flex'; 

            ignoreNextSpaceUp = true; 

            // R√©initialisation du jeu
            player.x = START_PLATFORM_REF.x + START_PLATFORM_REF.width / 2;
            player.y = START_PLATFORM_REF.y - player.height / 2;
            player.oldY = player.y; 
            player.velY = 0; 
            player.isGrounded = true; 
            isDead = false; 
            currentMaxSpeed = 8; 
            currentScore = 0; 
            lastMoneyScoreThreshold = 0; 
            lastDisplayedScore = 0; 
            scoreDisplayElement.textContent = `0`;
            particles = []; 
            player.rotation = 0; 
            
            // R√©initialise la couleur du joueur et des bordures
            const initialPlatformColor = getRandomNeonColor(); 
            currentPlatforms = [];
            currentPlatforms.push({ x: START_PLATFORM_REF.x, y: START_PLATFORM_REF.y, width: START_PLATFORM_REF.width, height: START_PLATFORM_REF.height, color: initialPlatformColor, isSolid: true });
            updatePlayerAndBorderColor(initialPlatformColor); 
            
            for (let i = 0; i < 5; i++) { generateNewPlatform(); }

            updateHotbarDisplay(); 
        }
        
        function showUpgradeShop() {
            hideAllScreens();
            currentState = GAME_STATE.GRADES;
            menuContainer.style.display = 'block';
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gradeShop').style.display = 'flex'; 
            topHotbarElement.style.display = 'flex';
            updateUpgradeShopDisplay(); 
            updateHotbarDisplay(); 
        }

        function showGameOverScreen() {
            hideAllScreens();
            topHotbarElement.style.display = 'flex';
            gameOverScreenElement.style.display = 'flex'; 
        }
        
        function showRankingScreen() {
            hideAllScreens();
            currentState = GAME_STATE.RANKING;
            rankingScreenElement.style.display = 'flex';
            topHotbarElement.style.display = 'flex'; 
            fetchLeaderboard();
        }

        function togglePause() {
            if (currentState === GAME_STATE.PLAYING) {
                currentState = GAME_STATE.PAUSED;
                document.getElementById('pauseCurrentScore').textContent = `Score: ${Math.floor(currentScore)}`; 
                pauseMenuElement.style.display = 'flex'; 
            } else if (currentState === GAME_STATE.PAUSED) {
                currentState = GAME_STATE.PLAYING;
                pauseMenuElement.style.display = 'none';
            }
        }

        function quitGame() {
             currentState = GAME_STATE.MENU; 
             pauseMenuElement.style.display = 'none';
             saveGameData(); 
             showMenu();
        }
        
        function quitToMenuHTML() {
             window.location.href = '../../menu.html';
        }


        // --- D√âMARRAGE ET √âV√âNEMENTS ---
        
        document.getElementById('playButton').onclick = startGame;
        document.getElementById('gradesButton').onclick = showUpgradeShop; 
        document.getElementById('upgradeButton').onclick = handleUpgrade; 
        document.getElementById('backButton').onclick = showMenu;
        document.getElementById('continueButton').onclick = togglePause;
        document.getElementById('quitButton').onclick = quitGame; 
        document.getElementById('restartButton').onclick = startGame;
        document.getElementById('goToMenuButton').onclick = showMenu;
        document.getElementById('rankingButton').onclick = showRankingScreen; 
        document.getElementById('backToMenuFromRanking').onclick = showMenu; 
        document.getElementById('quitGameButton').onclick = quitToMenuHTML;
        document.getElementById('startMenuButton').onclick = showMenu; // NOUVEAU: Bouton du tutoriel
        
        // --- Initialisation du jeu
        resizeCanvas(); 
        
        // D√©marrage automatique du chargement avec le pseudo par d√©faut et boucle de re-tentative
        loadGameData(); 
        
        gameLoop(); 
        
    </script>
</body>
</html>