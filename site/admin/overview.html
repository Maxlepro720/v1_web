<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tableau de Bord Admin - Console de Jeu</title>
<style>
/* R√©utilisation et adaptation du style de connecte.html pour un look coh√©rent */
:root {
    --bg-color: #0b0c10;
    --card-bg: rgba(255, 255, 255, 0.05);
    --primary-color: #00bfff;
    --secondary-color: #1de9b6;
    --text-color: #fff;
    --light-text: #aaa;
    --border-color: #333;
    --shadow-color: rgba(0, 0, 0, 0.6);
}
*{box-sizing:border-box;margin:0;padding:0;font-family:'Segoe UI',Arial,sans-serif;}
body{background:var(--bg-color);color:var(--text-color);min-height:100vh;display:flex;flex-direction:column;}

/* Structure principale */
.dashboard-container {
    display: flex;
    flex-grow: 1;
    padding-top: 60px;
}

/* En-t√™te (style Search Console) */
.header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    padding: 0 20px;
    border-bottom: 1px solid var(--border-color);
    z-index: 1000;
}
.header-logo {
    font-size: 24px;
    font-weight: bold;
    color: var(--primary-color);
    margin-right: 40px;
}
.header-title {
    font-size: 18px;
    color: var(--light-text);
}

/* Barre Lat√©rale (Navigation) */
.sidebar {
    width: 250px;
    background: rgba(0, 0, 0, 0.3);
    padding: 20px 0;
    border-right: 1px solid var(--border-color);
    flex-shrink: 0;
    transition: width 0.3s ease;
}
.nav-group-title {
    color: var(--light-text);
    padding: 10px 20px 5px;
    font-size: 12px;
    text-transform: uppercase;
    font-weight: 600;
}
.nav-item {
    display: flex;
    align-items: center;
    padding: 12px 20px;
    cursor: pointer;
    font-size: 15px;
    transition: background 0.2s, color 0.2s;
    color: var(--light-text);
    border-left: 3px solid transparent;
}
.nav-item:hover {
    background: rgba(255, 255, 255, 0.05);
    color: var(--text-color);
}
.nav-item.active {
    background: rgba(0, 191, 255, 0.1);
    color: var(--primary-color);
    border-left-color: var(--primary-color);
    font-weight: 600;
}
.nav-item i {
    margin-right: 10px;
    font-size: 18px;
}

/* Contenu Principal */
.main-content {
    flex-grow: 1;
    padding: 20px;
    overflow-y: auto;
}
.content-section {
    display: none;
    animation: fadeIn 0.5s ease-out;
}
.content-section.active {
    display: block;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

h2 {
    font-size: 28px;
    margin-bottom: 20px;
    color: var(--primary-color);
}

/* Style des cartes/panneaux */
.card {
    background: var(--card-bg);
    backdrop-filter: blur(20px);
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 25px;
    box-shadow: 0 5px 15px var(--shadow-color);
}

/* Formulaires et entr√©es */
.form-group {
    margin-bottom: 15px;
}
.form-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: var(--light-text);
}
/* Base style for inputs and selects */
.form-control, .select-control {
    width: 100%;
    padding: 10px 15px;
    border-radius: 10px;
    color: var(--text-color);
    font-size: 15px;
    transition: all 0.3s;
    -webkit-appearance: none;
    appearance: none;
}
.form-control {
    background: rgba(255, 255, 255, 0.1); 
    border: 1px solid rgba(255, 255, 255, 0.2);
}
/* Style Sp√©cifique pour le menu d√©roulant (Couleur Secondary-Color) */
.select-control {
    background: rgba(29, 233, 182, 0.15); /* Utilisation de la secondary-color transparente */
    border: 1px solid var(--secondary-color); /* Bordure en secondary-color */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%231de9b6'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 15px center;
    background-size: 10px;
    padding-right: 35px;
}
.form-control:focus, .select-control:focus {
    border-color: var(--primary-color); 
    box-shadow: 0 0 10px rgba(0, 191, 255, 0.4);
    outline: none;
}

/* Boutons */
.btn {
    padding: 12px 25px;
    border: none;
    border-radius: 15px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    background: var(--primary-color);
    color: var(--text-color);
    box-shadow: 0 5px 15px rgba(0, 191, 255, 0.4);
}
.btn:hover {
    background: var(--secondary-color);
    box-shadow: 0 0 20px rgba(29, 233, 182, 0.6);
    transform: translateY(-2px);
}

/* Tableaux */
.ranking-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}
/* Ajout du curseur pointer pour les lignes cliquables */
.ranking-table tbody tr {
    cursor: pointer; 
}
.ranking-table tbody tr:hover {
    background: rgba(0, 191, 255, 0.05); /* Highlight on hover for click */
}

.ranking-table th, .ranking-table td {
    padding: 15px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
}
.ranking-table th {
    color: var(--primary-color);
    font-weight: 600;
    text-transform: uppercase;
    font-size: 14px;
    background: rgba(0, 191, 255, 0.05);
}


/* Affichage des statistiques */
.stats-results {
    margin-top: 5px; /* R√©duit l'espace car le titre est dans la sous-carte */
}
.stats-results div {
    background: rgba(255, 255, 255, 0.08);
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 8px;
    font-size: 15px;
    display: flex;
    justify-content: space-between;
}
.stats-results strong {
    color: var(--secondary-color);
}

/* Logs */
#logContent {
    background: #111;
    color: #00ff77; /* Couleur n√©on verte pour les logs */
    padding: 15px;
    border-radius: 10px;
    font-family: 'Consolas', 'Courier New', monospace;
    white-space: pre-wrap;
    max-height: 500px;
    overflow-y: auto;
    font-size: 12px;
}

.error-message {
    color: #ff5555;
    background: rgba(255, 85, 85, 0.1);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
}
.loading-message {
    color: var(--primary-color);
    text-align: center;
    padding: 20px;
}
</style>
</head>
<body>

<div class="header">
    <div class="header-logo">üéÆ Console Admin</div>
    <div class="header-title">Tableau de Bord</div>
</div>

<div class="dashboard-container">
    <div class="sidebar">
        <div class="nav-group-title">Analytics & Donn√©es</div>
        <div class="nav-item active" data-tab="ranking">
            <i class="fas fa-trophy">üèÜ</i> Classement
        </div>
        <div class="nav-item" data-tab="player-stats">
            <i class="fas fa-user-chart">üìà</i> Statistiques de Joueur
        </div>
        <div class="nav-group-title" style="margin-top: 20px;">Gestion (Non Fonctionnel)</div>
        <div class="nav-item" data-tab="users">
            <i class="fas fa-users">üë•</i> Gestion des Utilisateurs
        </div>
        <div class="nav-item" data-tab="content">
            <i class="fas fa-cogs">‚öôÔ∏è</i> Param√®tres
        </div>
        <div class="nav-item" data-tab="reports">
            <i class="fas fa-bug">üö®</i> Rapports & Logs
        </div>
    </div>

    <div class="main-content">
        <div class="content-section active" id="ranking">
            <h2>Classement Global</h2>
            <div class="card">
                <p>Affichez le classement des meilleurs joueurs pour un jeu sp√©cifique. Cliquez sur un joueur pour voir toutes ses statistiques.</p>
                <div class="form-group">
                    <label for="rankingGameSelect">S√©lectionner un Jeu :</label>
                    <select id="rankingGameSelect" class="select-control">
                        </select>
                </div>
                <button class="btn" id="loadRankingBtn">Charger le Classement</button>
            </div>

            <div class="card" id="rankingResultCard" style="display:none;">
                <h3>Top 10 : <span id="rankingGameTitle"></span></h3>
                <div id="rankingTableContainer">
                    </div>
                <div id="rankingMessage" class="loading-message" style="display:none;">Chargement...</div>
                <div id="rankingError" class="error-message" style="display:none;"></div>
            </div>
        </div>

        <div class="content-section" id="player-stats">
            <h2>Statistiques de Joueur</h2>
            <div class="card">
                <p>Recherchez les statistiques d√©taill√©es d'un joueur pour **tous** les jeux.</p>
                <div class="form-group">
                    <label for="playerUsername">Nom d'utilisateur :</label>
                    <input type="text" id="playerUsername" class="form-control" placeholder="Entrez l'ID du joueur">
                </div>
                <button class="btn" id="loadPlayerStatsBtn">Charger les Statistiques pour Tous les Jeux</button>
            </div>

            <div class="card" id="statsResultCard" style="display:none;">
                <h3>Statistiques pour <span id="statsPlayerTitle"></span></h3>
                <div id="statsResultsContainer">
                    </div>
                <div id="statsMessage" class="loading-message" style="display:none;">Chargement...</div>
                <div id="statsError" class="error-message" style="display:none;"></div>
            </div>
        </div>
        
        <div class="content-section" id="users">
            <h2>Gestion des Utilisateurs</h2>
            <div class="card"><p>Fonctionnalit√© en cours de d√©veloppement...</p></div>
        </div>
        <div class="content-section" id="content">
            <h2>Param√®tres</h2>
            <div class="card"><p>Fonctionnalit√© en cours de d√©veloppement...</p></div>
        </div>
        
        <div class="content-section" id="reports">
            <h2>Rapports & Logs: Log Streams du Serveur</h2>
            <div class="card">
                <button class="btn" id="loadLogsBtn" style="margin-bottom: 20px;">Actualiser les Logs</button>
                
                <div id="logsMessage" class="loading-message" style="display:none;">Tentative de chargement des logs...</div>
                <div id="logsError" class="error-message" style="display:none;"></div>

                <pre id="logContent" style="margin-top: 20px;">Cliquez sur 'Actualiser les Logs' pour tenter l'appel direct...</pre>
            </div>
        </div>
    </div>
</div>

<script>
    // ----------------------------------------------------
    // ‚ö†Ô∏è ATTENTION S√âCURIT√â : CL√â API RENDER (Laiss√©es comme demand√©)
    // ----------------------------------------------------
    const RENDER_API_KEY = "rnd_vAPZzfcps0xotIbfFEwydEwuwKaF"; 
    const RENDER_SERVICE_ID = "srv-d3ao1bpgv73c739csfb0"; 

    // --- Configuration API ---
    const API_BASE_URL = "https://project-3-api-2bgb.onrender.com";
    
    // LISTE DES JEUX 
    const AVAILABLE_GAMES = {
        'astro': 'Astro Dodge', 
        'stickman_runner': 'Stickman Runner',
        'skull_arena': 'Skull Arena' 
    };
    
    // --- Gestion des Onglets ---
    const navItems = document.querySelectorAll('.nav-item');
    const contentSections = document.querySelectorAll('.content-section');
    const playerUsernameInput = document.getElementById('playerUsername');

    function switchTab(targetId) {
        navItems.forEach(i => i.classList.remove('active'));
        contentSections.forEach(s => s.classList.remove('active'));

        const targetNavItem = document.querySelector(`.nav-item[data-tab="${targetId}"]`);
        if (targetNavItem) {
            targetNavItem.classList.add('active');
            document.getElementById(targetId).classList.add('active');
        }
    }

    navItems.forEach(item => {
        item.addEventListener('click', () => {
            const targetId = item.getAttribute('data-tab');
            switchTab(targetId);
            
            if(targetId === 'ranking') {
                populateRankingGameSelector();
            }
        });
    });

    // --- Fonction utilitaire pour les API ---
    async function fetchData(endpoint, method = 'GET', body = null) {
        const url = `${API_BASE_URL}/${endpoint}`; 
        
        const options = {
            method: method,
            headers: {} 
        };

        if (body !== null) { 
            options.headers['Content-Type'] = 'application/json';
            options.body = JSON.stringify(body);
        }
        
        if (method === 'GET' && body === null) {
             delete options.headers['Content-Type'];
        }

        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text(); 
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    // Non-JSON response
                }
                
                const errorMessage = errorData.message || `Erreur HTTP ${response.status} (${response.statusText})`;
                throw new Error(errorMessage);
            }
            return await response.json();
        } catch (error) {
            console.error("Erreur de requ√™te API:", error);
            throw error;
        }
    }

    // --- Remplissage du menu d√©roulant de classement ---
    function populateRankingGameSelector() {
        const rankingGameSelect = document.getElementById('rankingGameSelect');
        
        // Emp√™che le remplissage multiple
        if (rankingGameSelect.options.length > 0) return;

        for (const [key, value] of Object.entries(AVAILABLE_GAMES)) {
            const option = new Option(value, key);
            rankingGameSelect.add(option);
        }
    }
    
    populateRankingGameSelector();

    // --- 1. Logique du Classement (Grade conditionnel + Clic vers Stats) ---
    const loadRankingBtn = document.getElementById('loadRankingBtn');
    const rankingGameSelect = document.getElementById('rankingGameSelect');
    const rankingTableContainer = document.getElementById('rankingTableContainer');
    const rankingGameTitle = document.getElementById('rankingGameTitle');
    const rankingResultCard = document.getElementById('rankingResultCard');
    const rankingMessage = document.getElementById('rankingMessage');
    const rankingError = document.getElementById('rankingError');

    loadRankingBtn.addEventListener('click', async () => {
        const gameId = rankingGameSelect.value;
        if (!gameId) {
            alert("Veuillez s√©lectionner un jeu.");
            return;
        }

        rankingResultCard.style.display = 'none';
        rankingError.style.display = 'none';
        rankingMessage.textContent = "Chargement du classement...";
        rankingMessage.style.display = 'block';

        try {
            let endpoint;
            let method = 'GET';

            if (gameId === 'skull_arena') {
                endpoint = `skull_arena_get_leaderboard`; 
            } else {
                endpoint = `${gameId}/leaderboard`;
            }

            const data = await fetchData(endpoint, method); 
            
            let leaderboardData = (gameId === 'skull_arena') ? (data.data || []) : (data.leaderboard || []);

            rankingTableContainer.innerHTML = generateRankingTable(leaderboardData, gameId); 
            rankingGameTitle.textContent = AVAILABLE_GAMES[gameId];
            rankingResultCard.style.display = 'block';
            rankingMessage.style.display = 'none';
            
            setupRankingClickListeners(); // D√©marrage des √©couteurs de clic
        } catch (error) {
            rankingError.textContent = `Erreur lors du chargement du classement (route: ${gameId === 'skull_arena' ? 'skull_arena_get_leaderboard' : gameId + '/leaderboard'}, m√©thode GET): ${error.message}.`;
            rankingError.style.display = 'block';
            rankingMessage.style.display = 'none';
        }
    });

    function generateRankingTable(rankingData, gameId) {
        if (rankingData.length === 0) {
            let message = 'Aucun classement trouv√© pour ce jeu.';
            if (gameId === 'skull_arena') {
                message += '<br>V√©rifiez si la table "Skull Arena" contient des donn√©es valides sur votre serveur Supabase.';
            }
            return `<p class="error-message">${message}</p>`;
        }

        // 1. D√©terminer si la colonne Grade est n√©cessaire (SEULEMENT pour Stickman Runner)
        const showGrade = (gameId === 'stickman_runner');
        
        // 2. Construire l'en-t√™te du tableau
        let html = '<table class="ranking-table"><thead><tr><th>#</th><th>Joueur</th><th>Meilleur Score</th>';
        if (showGrade) {
            html += '<th>Grade</th>';
        }
        html += '</tr></thead><tbody>';
        
        // 3. Construire le corps du tableau
        rankingData.forEach((player, index) => {
            const username = player.username || player.name || 'Inconnu';
            
            const score = player.PR_Score !== undefined ? player.PR_Score : 
                            (player.best_score !== undefined ? player.best_score : 
                            (player.Best_Vague !== undefined ? player.Best_Vague : 
                            (player.wave !== undefined ? player.wave : 0))); 
            
            const grade = player.grade || 'N/A'; 

            // Ajout de data-username pour la fonction de clic
            html += `<tr data-username="${username}">`; 
            html += `<td>${index + 1}</td>`;
            html += `<td>${username}</td>`;
            html += `<td>${score}</td>`;
            
            if (showGrade) {
                // Affiche la grade SEULEMENT si c'est Stickman Runner
                html += `<td>${grade}</td>`;
            }
            html += `</tr>`;
        });
        
        html += '</tbody></table>';
        return html;
    }

    function setupRankingClickListeners() {
        document.querySelectorAll('.ranking-table tbody tr').forEach(row => {
            row.addEventListener('click', (event) => {
                const username = row.getAttribute('data-username');
                if (username) {
                    // 1. Switch tab
                    switchTab('player-stats');
                    // 2. Set username input
                    playerUsernameInput.value = username;
                    // 3. Load stats for that user (all games)
                    loadAllPlayerStats(username);
                }
            });
        });
    }


    // --- 2. Logique des Statistiques de Joueur (Multi-Jeux) ---
    const loadPlayerStatsBtn = document.getElementById('loadPlayerStatsBtn');
    const statsResultsContainer = document.getElementById('statsResultsContainer');
    const statsPlayerTitle = document.getElementById('statsPlayerTitle');
    const statsResultCard = document.getElementById('statsResultCard');
    const statsMessage = document.getElementById('statsMessage');
    const statsError = document.getElementById('statsError');

    loadPlayerStatsBtn.addEventListener('click', () => {
        const username = playerUsernameInput.value.trim();
        if (!username) {
            alert("Veuillez entrer l'ID du joueur.");
            return;
        }
        loadAllPlayerStats(username);
    });
    
    // Nouvelle fonction pour charger les stats de tous les jeux
    async function loadAllPlayerStats(username) {
        statsResultCard.style.display = 'none';
        statsError.style.display = 'none';
        statsMessage.textContent = `Chargement des statistiques pour ${username}...`;
        statsMessage.style.display = 'block';
        statsResultsContainer.innerHTML = '';
        statsPlayerTitle.textContent = username;
        statsResultCard.style.display = 'block';

        const gameResults = {};
        let successCount = 0;

        // Boucle pour charger les stats de tous les jeux
        for (const [gameId, gameName] of Object.entries(AVAILABLE_GAMES)) {
            try {
                let endpoint;
                let method;
                let body = null;

                if (gameId === 'skull_arena') {
                    endpoint = `skull_arena_get_data`;
                    method = 'POST';
                    body = { username: username };
                } else {
                    endpoint = `${gameId}/load_data/${username}`; 
                    method = 'GET';
                }

                const data = await fetchData(endpoint, method, body);
                gameResults[gameId] = data.data || data; 

            } catch (error) {
                gameResults[gameId] = { status: "error", message: `Erreur de connexion: ${error.message}` };
            }
        }

        // Rendu des r√©sultats
        let htmlContent = '';
        
        for (const [gameId, gameName] of Object.entries(AVAILABLE_GAMES)) {
            const statsData = gameResults[gameId];
            let gameHtml;

            if (statsData.status === "error") {
                // Erreur de connexion / serveur
                gameHtml = `<p class="error-message" style="margin-top: 10px;">${statsData.message.replace('Erreur de connexion: ', '')}</p>`;
            } else {
                // Traitement sp√©cifique pour Skull Arena (aplatissement des niveaux)
                let processedStats = statsData;
                if (gameId === 'skull_arena' && (processedStats.levels || processedStats.levels === 0)) {
                    const levels = processedStats.levels || {};
                    processedStats = {
                        ...processedStats,
                        "Cr√¢nes": processedStats.skulls, 
                        "Meilleure Vague": processedStats.best_wave, 
                        "UP_D√©g√¢t": levels.damage,
                        "UP_Port√©e": levels.range,
                        "UP_Vitesse_Perso": levels.speed,
                        "UP_Cadence_Tir": levels.fire
                    };
                    delete processedStats.levels;
                    delete processedStats.skulls;
                    delete processedStats.best_wave;
                }
                
                gameHtml = generatePlayerStats(processedStats, true); 
                
                if (gameHtml.includes('Aucune statistique trouv√©e')) {
                    // Style sp√©cifique pour "non trouv√©" (pas une erreur de connexion)
                    gameHtml = `<p class="error-message" style="margin-top: 10px; background: rgba(255, 165, 0, 0.1); color: #ff9900; border: 1px solid #ff9900;">Aucune statistique trouv√©e pour ce joueur.</p>`;
                } else {
                    successCount++;
                }
            }
            
            // Structure de la carte pour chaque jeu
            htmlContent += `
                <div class="card" style="margin-bottom: 20px; padding: 20px; border: 1px solid var(--secondary-color);">
                    <h4 style="color: var(--secondary-color); margin-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 10px;">${gameName}</h4>
                    <div class="stats-results">
                        ${gameHtml}
                    </div>
                </div>
            `;
        }

        statsResultsContainer.innerHTML = htmlContent;
        statsMessage.style.display = 'none';

        if (successCount === 0) {
            statsError.textContent = "Aucune statistique significative trouv√©e pour ce joueur dans aucun des jeux.";
            statsError.style.display = 'block';
        } else {
            statsError.style.display = 'none';
        }
    }


    function generatePlayerStats(statsData, isSubSection = false) {
        if (!statsData || Object.keys(statsData).length === 0 || statsData.status === "error" || statsData.message === "Donn√©es Skull Arena introuvables. Initialisation...") {
            return isSubSection ? 'Aucune statistique trouv√©e pour ce joueur.' : '<p class="error-message">Aucune statistique trouv√©e pour ce joueur et ce jeu (ou joueur non initialis√©).</p>';
        }

        // Cl√©s √† exclure de l'affichage
        const keysToExclude = ['id', 'username', 'created_at', 'updated_at', 'status', 'message', 'leaderboard', 'Voiture', 'skulls', 'best_wave']; 
        let html = '';
        let hasData = false;

        for (const key in statsData) {
            if (statsData.hasOwnProperty(key) && !keysToExclude.includes(key) && statsData[key] !== undefined) {
                const value = statsData[key];
                
                if (typeof value === 'object' && value !== null) continue; 
                
                // Formate les cl√©s comme 'best_score' en 'Best Score'
                const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());

                html += `
                    <div>
                        <span>${formattedKey} :</span>
                        <strong>${value}</strong>
                    </div>
                `;
                hasData = true;
            }
        }
        
        return hasData ? html : (isSubSection ? 'Aucune statistique trouv√©e pour ce joueur.' : '<p class="error-message">Aucune statistique trouv√©e pour ce joueur et ce jeu (ou joueur non initialis√©).</p>');
    }

    // --- 3. Logique des Log Streams (Appel Direct Conserv√©) ---
    const loadLogsBtn = document.getElementById('loadLogsBtn');
    const logContent = document.getElementById('logContent');
    const logsMessage = document.getElementById('logsMessage');
    const logsError = document.getElementById('logsError');

    loadLogsBtn.addEventListener('click', loadServerLogs);

    async function loadServerLogs() {
        logsError.style.display = 'none';
        logsMessage.textContent = "Tentative de r√©cup√©ration des logs via l'API Render...";
        logsMessage.style.display = 'block';
        logContent.textContent = "Connexion √† l'API Render en cours...";
        
        // Ceci est le point o√π le code client √©chouerait dans un navigateur standard
        // pour acc√©der √† une API externe s√©curis√©e sans proxy.
        try {
            const url = `https://api.render.com/v1/services/${RENDER_SERVICE_ID}/logs?limit=100`;

            const response = await fetch(url, {
                headers: {
                    // Utilisation des cl√©s expos√©es comme demand√© (NON S√âCURIS√â)
                    'Authorization': `Bearer ${RENDER_API_KEY}`,
                    'Accept': 'text/plain' 
                }
            });

            if (!response.ok) {
                // Si l'erreur n'est pas CORS, elle sera captur√©e ici (ex: cl√© invalide)
                throw new Error(`Erreur HTTP ${response.status}: Impossible d'acc√©der aux logs.`);
            }

            const text = await response.text();
            logContent.textContent = text;
            logsMessage.style.display = 'none';
            logsError.style.display = 'none';
            
        } catch (error) {
            // Bloc qui capture l'erreur CORS ou toute autre erreur de connexion
            logsError.textContent = `√âchec de l'acc√®s aux logs : ${error.message}. (Si le message est 'Failed to fetch' ou 'CORS', c'est que l'appel direct est bloqu√© par la s√©curit√© du navigateur.)`;
            logContent.textContent = `√âchec de la r√©cup√©ration des logs.\nD√©tail technique: ${error.message}`;
            logsError.style.display = 'block';
            logsMessage.style.display = 'none';
        }
    }


</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
</body>
</html>