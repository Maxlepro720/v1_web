<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Clicker Game</title>
    <style>
        /* --- Styles CSS --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #232323; overflow: hidden; }

.container { display: flex; width: 100vw; height: 100vh; position: relative; overflow: hidden; }

.main-area { flex: 1; background: #1b1b1b; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; position: relative; min-width: 0; }

.title { color: #ffffff; font-size: clamp(32px, 6vw, 60px); font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }

.score-counter { color: #ffffff; font-size: clamp(20px, 3vw, 32px); font-weight: bold; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); background: rgba(255, 255, 255, 0.1); padding: 8px 25px; border-radius: 20px; backdrop-filter: blur(10px); }

.to-send { color: #ffffff; font-size: clamp(14px, 2vw, 20px); margin-bottom: 30px; opacity: 0.9; }

.click-button { width: min(30vh, 30vw, 220px); height: min(30vh, 30vw, 220px); max-width: 220px; max-height: 220px; aspect-ratio: 1/1; border-radius: 50%; background: linear-gradient(145deg, #ffd966, #ffb84d); border: 6px solid #ff6b35; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 10px 30px rgba(255, 107, 53, 0.4); position: relative; overflow: hidden; flex-shrink: 0; }

.click-button::before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; height: 85%; border-radius: 50%; background-size: cover; background-position: center; }

.click-button:hover { transform: scale(1.1); box-shadow: 0 15px 40px rgba(255, 107, 53, 0.6); }

.click-button:active { transform: scale(0.95); box-shadow: 0 5px 20px rgba(255, 107, 53, 0.3); }

.timer-counter { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #FFFFFF; font-size: clamp(12px, 1.5vw, 16px); font-weight: bold; background: rgba(0, 0, 0, 0.3); padding: 10px 25px; border-radius: 30px; backdrop-filter: blur(10px); min-width: 200px; max-width: 90%; text-align: center; }

.timer-bar { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); width: min(250px, 80%); height: 4px; background: rgba(255, 255, 255, 0.2); border-radius: 2px; overflow: hidden; }

.timer-bar-fill { height: 100%; background: linear-gradient(90deg, #10b981, #3b82f6); border-radius: 2px; transition: width 0.1s linear; }

.status-label { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #FFFFFF; font-size: clamp(11px, 1.5vw, 14px); padding: 6px 14px; border-radius: 8px; background: rgba(0, 0, 0, 0.5); max-width: 90%; text-align: center; }

.sidebar { width: clamp(280px, 30vw, 350px); max-width: 100vw; background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%); padding: 20px; position: absolute; right: 0; top: 0; height: 100vh; transform: translateX(0); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 100; overflow-y: auto; box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3); }

.sidebar.hidden { transform: translateX(100%); }

/* -------------------------------------
   MODIFICATIONS POUR LE BOUTON MENU 
   ------------------------------------- */
.toggle-sidebar-btn { 
    position: absolute; 
    top: 20px; 
    left: 80px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    color: white; 
    border: none; 
    width: clamp(40px, 6vw, 50px); 
    height: clamp(40px, 6vw, 50px); 
    border-radius: 50%; 
    cursor: pointer; 
    z-index: 101; 
    /* Retire la transition de scale pour qu'il ne bouge pas au survol */
    transition: box-shadow 0.3s ease; 
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transform: none; /* S'assure qu'il n'y a pas de transformation de base */
}

/* D√©sactive l'effet de zoom au survol */
.toggle-sidebar-btn:hover { 
    transform: none; 
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); 
}

/* Cache le contenu interne du bouton (s'il y a du texte ou une ancienne ic√¥ne) */
.toggle-sidebar-btn > * {
    display: none;
}

/* Style des barres du hamburger */
.toggle-sidebar-btn::before, 
.toggle-sidebar-btn::after,
.toggle-sidebar-btn .hamburger-middle { /* Ajout d'une barre centrale via un √©l√©ment interne (besoin d'un <span> dans le HTML) */
    content: '';
    position: absolute;
    width: 60%;
    height: 3px; /* √âpaissi l√©g√®rement les barres pour la visibilit√© */
    background: white;
    border-radius: 1px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    left: 20%; /* Centre les barres */
}

/* Positionnement des barres (hamburger) */
.toggle-sidebar-btn::before {
    transform: translateY(-9px); /* Barre du haut */
}

.toggle-sidebar-btn .hamburger-middle { 
    /* La barre du milieu est g√©r√©e par le span .hamburger-middle */
    top: 50%;
    transform: translateY(-50%);
}

.toggle-sidebar-btn::after {
    transform: translateY(9px); /* Barre du bas */
}

/* Transformation en croix (classe .open ajout√©e par JS) */
.toggle-sidebar-btn.open::before {
    transform: translateY(0) rotate(45deg); /* Barre du haut pivote pour former le bras de la croix */
}

.toggle-sidebar-btn.open::after {
    transform: translateY(0) rotate(-45deg); /* Barre du bas pivote pour former l'autre bras de la croix */
}

.toggle-sidebar-btn.open .hamburger-middle {
    opacity: 0; /* La barre du milieu dispara√Æt */
}
/* -------------------------------------
   FIN DES MODIFICATIONS POUR LE BOUTON MENU 
   ------------------------------------- */

.close-btn { 
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); 
    color: white; 
    border: none; 
    width: clamp(35px, 5vw, 40px); 
    height: clamp(35px, 5vw, 40px); 
    border-radius: 12px; 
    cursor: pointer; 
    font-size: clamp(18px, 3vw, 24px); 
    font-weight: bold; 
    position: absolute; 
    top: 20px; 
    right: 20px; 
    transition: all 0.2s ease; 
    box-shadow: 0 2px 10px rgba(239, 68, 68, 0.3); 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    line-height: 1;
}

.close-btn:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 4px 15px rgba(239, 68, 68, 0.5); }

.close-btn:disabled { background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); cursor: not-allowed; opacity: 0.6; }

.sidebar-title { color: #f8fafc; font-size: clamp(20px, 3vw, 28px); font-weight: bold; margin-bottom: 25px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }

.section-title { color: #cbd5e1; font-size: clamp(11px, 1.5vw, 13px); font-weight: bold; margin-top: 20px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }

.session-code { color: #60a5fa; font-size: clamp(22px, 3.5vw, 32px); font-weight: bold; margin-bottom: 18px; text-shadow: 0 2px 8px rgba(96, 165, 250, 0.3); word-break: break-all; }

.username-label, .player-count { color: #f8fafc; font-size: clamp(14px, 2vw, 16px); margin-bottom: 10px; }

.player-item { color: #10b981; font-size: clamp(13px, 1.8vw, 15px); margin: 8px 0; padding: 8px 12px; background: rgba(16, 185, 129, 0.1); border-radius: 10px; border-left: 3px solid #10b981; transition: all 0.3s ease; word-break: break-word; }

.player-item:hover { background: rgba(16, 185, 129, 0.2); transform: translateX(5px); }

.player-item.waiting { color: #64748b; background: rgba(100, 116, 139, 0.1); border-left: 3px solid #64748b; }

.join-input { width: 100%; height: clamp(40px, 5vh, 45px); border-radius: 12px; border: 2px solid #475569; background: rgba(51, 65, 85, 0.6); color: #f8fafc; padding: 0 14px; font-size: clamp(13px, 1.8vw, 15px); margin-top: 10px; transition: all 0.3s ease; backdrop-filter: blur(5px); }

.join-input:focus { outline: none; border-color: #60a5fa; background: rgba(51, 65, 85, 0.8); box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2); }

.join-input::placeholder { color: #94a3b8; }

.join-button { width: 100%; height: clamp(42px, 5.5vh, 48px); border-radius: 12px; border: none; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; font-size: clamp(13px, 1.8vw, 15px); font-weight: bold; cursor: pointer; margin-top: 12px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); }

.join-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); }

.join-button:active { transform: translateY(0); }

.upgrade-button { width: 100%; height: clamp(42px, 5.5vh, 48px); border-radius: 12px; border: none; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; font-size: clamp(13px, 1.8vw, 15px); font-weight: bold; cursor: pointer; margin-top: 12px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3); }

.upgrade-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4); background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); }

.upgrade-button:active { transform: translateY(0); }

.sidebar-status { color: #94a3b8; font-size: clamp(11px, 1.5vw, 12px); margin-top: 10px; min-height: 20px; word-break: break-word; }

.back-btn { 
    position: absolute; 
    top: 20px; 
    left: 20px; 
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); 
    color: white; 
    border: none; 
    width: clamp(40px, 6vw, 50px); 
    height: clamp(40px, 6vw, 50px); 
    border-radius: 50%; 
    cursor: pointer; 
    font-size: clamp(18px, 3vw, 24px); 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); 
    transition: all 0.3s ease, transform 0.6s ease-out; 
    z-index: 102; 
    transform: scale(1) rotate(0deg); 
}

.back-btn:hover { 
    transform: scale(1.1) rotate(360deg); 
    box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6); 
}

/* Joueur en attente */
.player-item {
    padding: 8px;
    margin-bottom: 5px;
    border-radius: 4px;
    background-color: #374151;
    border-left: 3px solid #10b981;
    transition: all 0.2s ease-in-out;
}

/* Joueur en attente */
.player-item.waiting {
    color: #64748b;
    background: #1f2937;
    border-left: 3px solid #64748b;
}

/* L'utilisateur courant */
.player-item-me {
    font-weight: bold;
    color: #fcd34d;
    border-left: 3px solid #fcd34d; 
    background: #3f3f46; 
}

/* Le cr√©ateur de la session (la couronne üëë) */
.player-item-creator {
    color: #ff6b35;
    border-left: 3px solid #ff6b35; 
    background: rgba(255, 107, 53, 0.15); 
}

/* -------------------------------------
    üì≤ MODIFICATIONS CSS POUR MOBILE (Max 768px)
    ------------------------------------- */
@media (max-width: 768px) {
    .sidebar { width: 85vw; }
    .main-area { 
        padding: 15px; 
        display: flex;
        flex-direction: column; 
        justify-content: space-between; 
        align-items: center;
    }
    
    .click-button { width: min(40vw, 40vh, 200px); height: min(40vw, 40vh, 200px); flex-shrink: 0; }
    
    /* Bouton "Rejoindre" pour mobile (visible uniquement sur mobile) */
    #joinButtonMobile {
        display: block; 
        width: 90%;
        height: 50px;
        margin: 10px auto;
        order: 3; 
        border-radius: 12px; border: none; 
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); 
        color: white; font-size: 15px; font-weight: bold; cursor: pointer; 
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        transition: all 0.3s ease;
    }
    
    #joinButtonMobile:hover { transform: translateY(-2px); }
    #joinButtonMobile:active { transform: translateY(0); }

    /* Input pour mobile (visible uniquement sur mobile) */
    #joinInputMobile {
        display: block; 
        width: 90%;
        height: 45px;
        margin: 0 auto;
        order: 4; 
        border-radius: 12px; border: 2px solid #475569; 
        background: rgba(51, 65, 85, 0.6); color: #f8fafc; 
        padding: 0 14px; font-size: 15px;
        margin-bottom: 20px; 
    }
    
    #joinInputMobile::placeholder { color: #94a3b8; }
    #joinInputMobile:focus { outline: none; border-color: #60a5fa; background: rgba(51, 65, 85, 0.8); box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2); }

    /* Ordre des √©l√©ments existants dans main-area */
    .score-counter {
        order: 1; 
        margin-bottom: 30px; 
        margin-top: 50px; 
    }

    .click-button {
        order: 2; 
        margin: 30px 0; 
    }

    /* Cache les contr√¥les originaux (sidebar ou desktop) */
    .join-input, .join-button, .upgrade-button {
        display: none !important; 
    }
    
    /* Ajustements divers pour le header */
    .back-btn { top: 10px; left: 10px; }
    .toggle-sidebar-btn { top: 10px; left: 70px; }
    .title { order: -2; margin-top: 0; }
    .to-send { order: -1; margin-bottom: 0; }
    
    /* Simplification de l'affichage pour le mobile */
    .timer-bar, .timer-counter, .status-label { 
        display: none !important; 
    } 
}
@media (max-width: 480px) {
    .sidebar { width: 90vw; }
    .click-button { width: min(50vw, 45vh, 180px); height: min(50vw, 45vh, 180px); }
}
    </style>

</head>
<body>
    <div class="container">
        <div class="main-area">
            <a href="menu.html"><button class="back-btn">‚Üê</button></a>
            <button class="toggle-sidebar-btn" id="toggleSidebar"></button>

            <div class="title">Clicker</div>
            <div class="score-counter" id="scoreCounter">0</div> 
            <div class="to-send" id="toSend">-- 0 --</div>
            <button class="click-button" id="clickButton"></button>

            <button class="join-button" id="joinButtonMobile" style="display:none;" onclick="handleJoinSessionMobile()">Rejoindre</button>
            <input type="text" class="join-input" id="joinInputMobile" placeholder="Entrer un code ou /cha code" style="display:none;">
            <div class="timer-bar">
                <div class="timer-bar-fill" id="timerBarFill"></div>
            </div>
            <div class="timer-counter" id="timerCounter">Rafra√Æchissement : lancement</div>
            <div class="status-label" id="statusLabel"></div>
        </div>

        <div class="sidebar hidden" id="sidebar"> 
            <button class="close-btn" id="closeBtn">√ó</button>
            <div class="sidebar-title">Session</div>

            <div class="section-title">Code de session</div>
            <div class="session-code" id="sessionCode">Chargement...</div>

            <div class="section-title">Utilisateur</div>
            <div class="username-label" id="usernameLabel">Utilisateur</div>

            <div class="section-title">Joueurs pr√©sents</div>
            <div class="player-count" id="playerCount">1/5</div>

            <div id="playersList">
                <div class="player-item" id="player1">üë§ Vous</div>
                <div class="player-item waiting" id="player2">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player3">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player4">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player5">‚ö™ En attente...</div>
            </div>

            <div class="section-title">Rejoindre / Changer nom</div>
            <input type="text" class="join-input" id="joinInput" placeholder="Entrer un code ou /cha code">
            <button class="join-button" id="joinButton">Rejoindre/Changer</button>
            <a href="upgrade.html" target="_blank"><button class="upgrade-button" id="upgradeButton">‚ö° Am√©lioration</button></a>

            <div class="sidebar-status" id="sidebarStatus"></div>
        </div>
    </div>

    <script>
        // --- VARIABLES GLOBALES ET CONSTANTES ---
        const API_URL = "https://project-3-api-2bgb.onrender.com";
        
        // Fr√©quences pour les cycles
        const SCORE_REFRESH_PERIOD_SECONDS = 10; 
        const CLICKS_MIN_SECONDS = 4; // Min 4 secondes
        const CLICKS_MAX_SECONDS = 8; // Max 8 secondes
        
        let clickCount = 0;
        let lastClickTime = 0;
        let clickIntervals = [];
        let username = localStorage.getItem("username");
        
        // Flag pour √©viter de relancer logout si d√©j√† fait lors de la redirection
        let isRedirecting = false; 

        let timerInterval; // Pour le rafra√Æchissement du score (toutes les 10s)
        let clicksTimeout; // Pour l'envoi al√©atoire des clics (4-8s)
        
        // --- FONCTIONS DE GESTION DES CYCLES ET DE L'√âTAT ---
        
        function stopAllCycles() {
            clearInterval(timerInterval);
            clearTimeout(clicksTimeout);
        }
        
        function stopClicksInterval() {
            clearTimeout(clicksTimeout);
        }
        
        /**
         * D√©marre le minuteur al√©atoire pour le prochain envoi de clics (entre 4 et 8 secondes).
         */
        function startClicksInterval() {
            stopClicksInterval(); 
            
            const duration = Math.floor(Math.random() * (CLICKS_MAX_SECONDS - CLICKS_MIN_SECONDS + 1)) + CLICKS_MIN_SECONDS;
            
            clicksTimeout = setTimeout(sendClicksRandomly, duration * 1000);
            console.log(`[CLICS] Prochain envoi al√©atoire de clics dans : ${duration}s`);
        }

        function updateDisplay(timeLeft) {
            const timerCounter = document.getElementById('timerCounter');
            const timerBarFill = document.getElementById('timerBarFill');
            
            if (timerCounter) {
                timerCounter.textContent = `Rafra√Æchissement dans : ${timeLeft}s`;
            }
            if (timerBarFill) {
                const percentage = (timeLeft / SCORE_REFRESH_PERIOD_SECONDS) * 100;
                timerBarFill.style.width = `${percentage}%`;
            }
        }

        function startScoreInterval(initialWaitTime = SCORE_REFRESH_PERIOD_SECONDS) {
            clearInterval(timerInterval);
            let timeLeft = initialWaitTime; 
            updateDisplay(timeLeft); 

            timerInterval = setInterval(() => {
                timeLeft--;
                updateDisplay(timeLeft); 
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameCycle(); 
                }
            }, 1000); 
        }

        async function gameCycle() {
            const sessionCode = document.getElementById('sessionCode').textContent;
            
             if (sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Chargement..." || sessionCode === "Cr√©ation...") {
                 console.warn("[SCORE] Session invalide. Tentative de prochain cycle.");
                 startScoreInterval(); 
                 return;
             }
            
            console.log(`[SCORE] D√©clenchement du rafra√Æchissement API (10s cycle) pour la session : ${sessionCode}`);

            const counterElement = document.getElementById('timerCounter');
            if (counterElement) {
                counterElement.textContent = "‚è≥";
            }
            
            // 1. Envoi des clics accumul√©s 
            await sendClicksRandomly();
            
            // 2. R√©cup√©ration des donn√©es (score et joueurs)
            await fetchGameData(); 
            
            // 3. Relance du minuteur des clics al√©atoires
            startClicksInterval();
            
            startScoreInterval(); // Relance l'intervalle de 10 secondes pour le score
        }
        
        // --- FONCTIONS DE COMMUNICATION ET DE JEU ---

        async function getPlayerSessionInfo() {
            try {
                // Utilise la m√™me URL de v√©rification qui renvoie les infos de session
                const playersResponse = await fetch(`${API_URL}/verify_session?id=${encodeURIComponent(username)}`);
                const playersData = await playersResponse.json();
                return playersData.status === "success" ? playersData : null;
            } catch (e) {
                console.error("Erreur lors de la r√©cup√©ration des infos de session:", e);
                return null;
            }
        }
        
        /**
         * G√®re la d√©connexion silencieuse.
         * @param {boolean} shouldLogout - Indique s'il faut appeler /logout (d√©connexion compl√®te).
         * @param {boolean} shouldRedirect - Indique s'il faut rediriger apr√®s l'op√©ration (vers index.html).
         */
        async function logoutSilently(shouldLogout, shouldRedirect) {
            if (isRedirecting && shouldRedirect) {
                return; 
            }
            
            console.log(`[LOGOUT] D√©connexion silencieuse (Logout: ${shouldLogout ? 'Oui' : 'Non'})...`);
            stopAllCycles();
            
            if (shouldRedirect) {
                isRedirecting = true;
            }

            const sessionCode = document.getElementById('sessionCode').textContent;
            let isCreator = false;
            let isInGroup = false;

            const sessionInfo = await getPlayerSessionInfo();
            if (sessionInfo && sessionInfo.status === "success") {
                isCreator = sessionInfo.creator === username;
                isInGroup = sessionInfo.session_code === sessionCode && !isCreator;
            }

            // 1. G√®re le /leave si le joueur est dans une session de groupe (ou si on ne fait PAS un logout complet et qu'il a une session)
            if (sessionCode !== "Aucune session" && sessionCode !== "Erreur" && sessionCode !== "Chargement..." && sessionCode !== "Cr√©ation...") {
                 // Si c'est une session de groupe OU si c'est la session personnelle mais que l'on veut juste "revenir au menu" (leave seulement, pas logout)
                 if (isInGroup || (!shouldLogout && sessionInfo && sessionInfo.session_code)) { 
                     console.log(`[LOGOUT] Envoi de /leave pour la session ${sessionCode}.`);
                     try {
                         await fetch(`${API_URL}/leave`, {
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify({ code: sessionCode, id: username })
                         });
                     } catch (e) {
                         console.error("Erreur lors du /leave silencieux:", e);
                     }
                 }
            }
            
            // 2. G√®re le /logout si demand√© (fermeture/redirection compl√®te).
            if (shouldLogout) {
                 const logoutData = JSON.stringify({ id: username });

                 if (navigator.sendBeacon) {
                     const blob = new Blob([logoutData], {type : 'application/json'});
                     navigator.sendBeacon(`${API_URL}/logout`, blob);
                 } else {
                     try {
                         const xhr = new XMLHttpRequest();
                         xhr.open("POST", `${API_URL}/logout`, false); 
                         xhr.setRequestHeader("Content-Type", "application/json");
                         xhr.send(logoutData);
                     } catch (e) {
                         console.error("Erreur lors du /logout silencieux (XHR):", e);
                     }
                 }
            }

            // 3. Redirection
            if (shouldRedirect) {
                window.location.href = 'index.html'; // Redirection vers la page de login
            }
        }
        
        // Bouton fl√®che (‚Üê) √† gauche : /logout (pour d√©truire la session personnelle et revenir √† login)
        async function handleBackButton() {
            logoutSilently(true, true); 
        }
        
        // √âv√©nement de fermeture de page : /logout silencieux (sans redirection)
        function handleLogoutOnClose(event) {
            if (isRedirecting) {
                return; 
            }
            logoutSilently(true, false); 
        }

        // Bouton croix (√ó) en haut √† droite : /leave de la session de groupe uniquement.
        async function handleLeaveSession() {
            // R√©cup√©ration des √©l√©ments n√©cessaires pour l'affichage et la fermeture
            const sessionCode = document.getElementById('sessionCode').textContent;
            const sidebarStatus = document.getElementById('sidebarStatus');
            const closeBtn = document.getElementById('closeBtn');
            const toggleBtn = document.getElementById('toggleSidebar');

            // On suppose que le code de session et l'username sont disponibles globalement
            if (!sessionCode || sessionCode === "Chargement...") {
                sidebarStatus.textContent = "‚ö†Ô∏è Code de session manquant ou en cours de chargement.";
                sidebarStatus.style.color = "#f59e0b";
                return;
            }

            try {
                // D√©sactivation du bouton pour √©viter les clics multiples
                if (closeBtn) closeBtn.disabled = true; 
                sidebarStatus.textContent = `Tentative de quitter la session ${sessionCode}... (Forc√©)`;
                sidebarStatus.style.color = "#f59e0b";

                // Requ√™te /leave forc√©e pour la session de groupe
                const response = await fetch(`${API_URL}/leave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: sessionCode, id: username })
                });
                const data = await response.json();

                if (data.status === "success") {
                    sidebarStatus.textContent = "‚úÖ D√©connexion de session effectu√©e.";
                    sidebarStatus.style.color = "#10b981";
                    
                    // Mise √† jour de l'√©tat du jeu
                    // (Ces fonctions sont n√©cessaires pour passer en mode solo)
                    stopAllCycles();
                    await loadMySession(); 
                    await fetchGameData();
                    launchGameCycle(); 
                    
                } else {
                    // Affiche le message d'erreur du serveur
                    sidebarStatus.textContent = `‚ùå Impossible de quitter : ${data.message}`;
                    sidebarStatus.style.color = "#ef4444";
                }
            } catch (e) {
                sidebarStatus.textContent = "‚ùå Erreur r√©seau lors de la d√©connexion de session forc√©e.";
                sidebarStatus.style.color = "#ef4444";
            } finally {
                // Nettoyage et fermeture de la barre lat√©rale dans tous les cas
                if (closeBtn) checkCloseButtonState(); // R√©active/v√©rifie l'√©tat du bouton
                document.getElementById('sidebar').classList.add('hidden');
                
                // Remet l'ic√¥ne de menu en position "hamburger"
                if (toggleBtn) {
                    toggleBtn.classList.remove('open'); 
                }
            }
        }
        
        /**
         * G√®re le changement de session (rejoindre une autre session ou /cha pour changer le nom de sa session perso).
         * @param {string} inputId - ID de l'input utilis√© (desktop ou mobile).
         */
        async function handleJoinSession(inputId = 'joinInput') {
            const joinInput = document.getElementById(inputId);
            const sessionCodeElement = document.getElementById('sessionCode');
            const sidebarStatus = document.getElementById('sidebarStatus');
            const joinButton = document.getElementById('joinButton');
            const joinButtonMobile = document.getElementById('joinButtonMobile');
            
            const input_value = joinInput.value.trim();
            
            if (!input_value) {
                sidebarStatus.textContent = "‚ö†Ô∏è Veuillez entrer un code ou la commande /cha.";
                sidebarStatus.style.color = "#f59e0b";
                return;
            }
            
            // D√©sactiver les boutons de join
            if (joinButton) joinButton.disabled = true;
            if (joinButtonMobile) joinButtonMobile.disabled = true;
            
            sidebarStatus.textContent = `Traitement de la demande pour "${input_value}"...`;
            sidebarStatus.style.color = "#60a5fa";

            const isChangeCommand = input_value.toLowerCase().startsWith('/cha ');
            const newCode = isChangeCommand ? input_value.substring(5).trim() : '';
            let isSuccessful = false;

            // ------------------------------------------
            // 1. GESTION DU CHANGEMENT DE NOM DE SESSION PERSO (/cha)
            // ------------------------------------------
            if (isChangeCommand) {
                
                if (newCode.length < 3) {
                    sidebarStatus.textContent = "‚ùå Le nouveau nom de session doit contenir au moins 3 caract√®res.";
                    sidebarStatus.style.color = "#ef4444";
                } else {
                    console.log(`[CHA] Tentative de changement de session personnelle √†: ${newCode}`);
                    
                    try {
                        const bodyData = { 
                            id: username, 
                            new_session_name: newCode // Cl√© corrig√©e pour /change_session
                        };

                        const response = await fetch(`${API_URL}/change_session`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(bodyData)
                        });
                        const data = await response.json();
                        console.log(data)

                        if (data.status === "success" && data.new_code === newCode) {
                            // Succ√®s du /change_session
                            stopAllCycles();
                            
                            // 1. Affiche le nouveau code
                            sessionCodeElement.textContent = newCode;
                            sessionCodeElement.dataset.forcedCode = newCode;
                            
                            // 2. Met √† jour imm√©diatement le score et la liste des joueurs
                            await fetchGameData
                
                            
                            sidebarStatus.textContent = `‚úÖ Nom de session personnelle mis √† jour: ${newCode}`;
                            sidebarStatus.style.color = "#10b981";
                            
                            // 3. Red√©marre le cycle de jeu
                            launchGameCycle(); 
                            isSuccessful = true;
                        } else {
                            // √âchec de l'API /change_session
                            sidebarStatus.textContent = `‚ùå Impossible de changer le nom: ${data.message || 'Erreur inconnue'}`;
                            sidebarStatus.style.color = "#ef4444";
                        }
                    } catch (e) {
                        sidebarStatus.textContent = "‚ùå Erreur r√©seau lors du changement de nom de session (/cha).";
                        sidebarStatus.style.color = "#ef4444";
                        console.error("Erreur /change_session:", e);
                    }
                }
                
                if (isSuccessful) {
                    joinInput.value = ""; 
                }
            } 
            // ------------------------------------------
¬† ¬† ¬† ¬† ¬† ¬† // 2. GESTION DE REJOINDRE UNE SESSION DE GROUPE (JOIN)
¬† ¬† ¬† ¬† ¬† ¬† // ------------------------------------------
¬† ¬† ¬† ¬† ¬† ¬† else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const codeToJoin = input_value;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log(`[JOIN] Tentative de rejoindre la session: ${codeToJoin}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let joinedSuccessfully = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // IMPORTANT: Quitter la session actuelle (pour que l'API puisse d√©sactiver la session personnelle du joueur).
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await logoutSilently(false, false); 

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Rejoindre la nouvelle session
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const response = await fetch(`${API_URL}/join`, {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† method: 'POST',
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† headers: { 'Content-Type': 'application/json' },
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† body: JSON.stringify({ code: codeToJoin, id: username })
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const data = await response.json();

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (data.status === "success") {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // --- SUCC√àS ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† stopAllCycles();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sessionCodeElement.textContent = codeToJoin;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sessionCodeElement.dataset.forcedCode = codeToJoin; 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // -----------------------------------------------------------------
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // D√âBUT DE LA CORRECTION
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // On attend 1.5s que le serveur ait le temps de mettre
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // √† jour la liste des joueurs AVANT de fetchGameData.
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("[JOIN] Succ√®s API. Attente de 1500ms pour synchro serveur...");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await new Promise(resolve => setTimeout(resolve, 1500)); 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // FIN DE LA CORRECTION
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // -----------------------------------------------------------------
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Met √† jour (maintenant) le score et la nouvelle liste des joueurs
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.log("[JOIN] Synchro termin√©e. R√©cup√©ration des donn√©es de jeu.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†   const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

                        await fetchGameData();

                        await sleep(1500);

                        const sessionCode = sessionCodeElement.textContent; // R√©cup√®re le code apr√®s la mise √† jour
                        await fetchPlayersInSession(sessionCode);

                        let syncSuccess = false;
                        const MAX_RETRIES = 3; 
                        for (let i = 0; i < MAX_RETRIES; i++) {
                            const delay = (i === 0) ? 1500 : 2000; 
                            await sleep(delay); 
                                
                            // N'appelle QUE la fonction cibl√©e :
                            syncSuccess = await fetchPlayersInSession(codeToJoin); 
                                
                            if (syncSuccess) {
                                break; 
                            }
                        }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sidebarStatus.textContent = `‚úÖ Session de groupe rejointe: ${codeToJoin}`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sidebarStatus.style.color = "#10b981";
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† launchGameCycle(); 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† joinedSuccessfully = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
                        // --- √âCHEC API ---
                        sidebarStatus.textContent = `‚ùå Impossible de rejoindre: ${data.message || 'Code invalide ou session pleine.'}`;
                        sidebarStatus.style.color = "#ef4444";
                        
                        // √âCHEC: Doit revenir √† sa session personnelle car l'ancienne a √©t√© d√©sactiv√©e.
                        console.log("[JOIN FAIL] Retour √† la session personnelle apr√®s √©chec de jonction.");
                        stopAllCycles();
                        await loadMySession(); 
                        await fetchGameData();
                        launchGameCycle();
                    }
                } catch (e) {
                    // --- √âCHEC R√âSEAU ---
                    sidebarStatus.textContent = "‚ùå Erreur r√©seau lors de la tentative de rejoindre.";
                    sidebarStatus.style.color = "#ef4444";
                    console.error("Erreur /join:", e);
                    
                    // √âCHEC R√âSEAU: Doit revenir √† sa session personnelle.
                    console.log("[JOIN FAIL] Retour √† la session personnelle apr√®s erreur r√©seau.");
                    stopAllCycles();
                    await loadMySession(); 
                    await fetchGameData();
                    launchGameCycle();
                }

                if (joinedSuccessfully) {
                     joinInput.value = ""; 
                }
            }

            // R√©activer les boutons de join
            if (joinButton) joinButton.disabled = false;
            if (joinButtonMobile) joinButtonMobile.disabled = false;
            checkCloseButtonState();
        }

        // Fonction d'aide pour g√©rer le bouton mobile
        function handleJoinSessionMobile() {
            handleJoinSession('joinInputMobile');
        }

        function onCLickerClick() {
            const statusLabel = document.getElementById('statusLabel'); 
            const toSend = document.getElementById('toSend'); 
            
            const now = Date.now() / 1000;
            let freq = 0;
            
            if (lastClickTime !== 0) {
                const interval = now - lastClickTime;
                clickIntervals.push(interval);
                if (clickIntervals.length > 5) clickIntervals.shift();
                const avg = clickIntervals.reduce((a, b) => a + b, 0) / clickIntervals.length;
                const clickFrequency = avg > 0 ? 1 / avg : 0;
                freq = clickFrequency; 
            }
            lastClickTime = now;

            if (freq > 20) { 
                if (statusLabel) {
                    statusLabel.textContent = "‚ö†Ô∏è Autoclicker d√©tect√© ‚ö†Ô∏è";
                    statusLabel.style.color = "#f87171";
                    setTimeout(() => { statusLabel.textContent = "", statusLabel.style.color = "#FFFFFF"; }, 1000);
                }
                return;
            }

            clickCount++;
            if (toSend) toSend.textContent = `-- ${clickCount} --`;
        }
        
        /**
         * Envoie les clics accumul√©s √† l'API et r√©initialise l'affichage.
         */
        async function sendClicksRandomly() {
            const sessionCode = document.getElementById('sessionCode').textContent;
            
            if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
                return;
            }
            
            const toSendValue = clickCount;
            
            try {
                if (toSendValue > 0) {
                    console.log(`[CLICS] Envoi de ${toSendValue} clics pour la session ${sessionCode}`);
                    
                    const response = await fetch(`${API_URL}/poire`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ session: sessionCode, click: toSendValue, id: username }) 
                    });
                    
                    if (response.ok) {
                        clickCount = 0; 
                        const toSend = document.getElementById('toSend');
                    } else {
                        console.error(`[CLICS] √âchec de l'envoi des clics: ${response.status}`);
                    }
                }
            } catch (e) {
                const statusLabel = document.getElementById('statusLabel');
                if (statusLabel) {
                    statusLabel.textContent = "‚ùå Erreur r√©seau envoi";
                    statusLabel.style.color = "#ef4444";
                }
            } finally {
                if (!timerInterval) { 
                     startClicksInterval();
                }
            }
        }
        
        async function fetchPlayers() {
            const username = localStorage.getItem("username"); 
            
            if (!username) {
                console.error("[FETCH_PLAYERS] Nom d'utilisateur non disponible. Arr√™t du rafra√Æchissement.");
                return;
            }
            
            const sessionCodeElement = document.getElementById('sessionCode');
            const currentDisplayedCode = sessionCodeElement.textContent; 
            const forcedCode = sessionCodeElement.dataset.forcedCode; 
            
            // V√©rifications initiales (si le code affich√© est un √©tat temporaire, on ne fait rien)
            if (currentDisplayedCode === "Chargement..." || currentDisplayedCode === "Aucune session" || currentDisplayedCode === "Erreur" || currentDisplayedCode === "Cr√©ation...") {
                return;
            }

            console.log(`[FETCH_PLAYERS] Requ√™te pour session: ${currentDisplayedCode}`);
            
            try {
                const playersResponse = await fetch(
                    // On utilise le code de session actuellement affich√© pour demander la v√©rification
                    `${API_URL}/verify_player_in_session?username=${encodeURIComponent(username)}&session_code=${encodeURIComponent(currentDisplayedCode)}`
                );
                
                const playersData = await playersResponse.json();
                console.log(playersData); // Affichage des donn√©es re√ßues (comme vous le faites)

                // Si la requ√™te √©choue ou ne renvoie pas de code valide 
                if (playersData.status !== "success" || !playersData.session_code) {
                    console.warn(`[FETCH_PLAYERS] √âchec de v√©rification pour ${currentDisplayedCode}: ${playersData.message || 'Donn√©es invalides.'}`);
                    return;
                }
                
                // Logique pour g√©rer le code forc√©
                if (forcedCode && playersData.session_code !== forcedCode) {
                    sessionCodeElement.textContent = forcedCode; 
                    return;
                }

                // Logique de pr√©vention des d√©synchronisations (si le serveur renvoie le mauvais code)
                if (playersData.session_code !== currentDisplayedCode) {
                    console.warn(`[FETCH_PLAYERS] D√©synchronisation d√©tect√©e. Serveur renvoie ${playersData.session_code} au lieu de ${currentDisplayedCode}.`);
                    // Pour l'instant, on ignore la mise √† jour pour ne pas √©craser l'affichage 'mode'
                    // Vous pouvez commenter le 'return' si vous voulez que l'affichage soit √©cras√©
                    // MAIS cela cause les probl√®mes de "joueurs qui disparaissent" que vous avez eus.
                    return; 
                }

                // --- üöÄ APPEL CRITIQUE MANQUANT ---
                
                // Mise √† jour de l'affichage du code (si on est synchro)
                sessionCodeElement.textContent = playersData.session_code; 
                sessionCodeElement.dataset.forcedCode = '';
                
                // üö® C'est l'appel qui met √† jour l'interface utilisateur !
                updatePlayersList(playersData.players || [], playersData.creator);
                
                // Mise √† jour de l'√©tat du bouton (si vous avez cette fonction)
                // checkCloseButtonState(); 
                
            } catch (e) {
                console.error("Erreur r√©seau ou JSON lors du rafra√Æchissement des joueurs:", e);
            }
        }
        async function fetchPlayersInSession(sessionCode) {
            const username = localStorage.getItem("username");

            console.log(`[FETCH_PLAYERS_IN_SESSION] Tentative de r√©cup√©ration des joueurs pour la session cibl√©e: ${sessionCode}`);

            try {
                // *** Ceci utilise la NOUVELLE route serveur /verify_player_in_session ***
                const playersResponse = await fetch(
                    `${API_URL}/verify_player_in_session?username=${encodeURIComponent(username)}&session_code=${encodeURIComponent(sessionCode)}`
                );
                
                const playersData = await playersResponse.json();
                console.log(playersData)
                
                if (playersData.status === "success" && playersData.session_code === sessionCode) {
                    
                    // Mise √† jour de l'affichage avec les donn√©es cibl√©es
                    updatePlayersList(playersData.players || [], playersData.creator);
                    checkCloseButtonState(); 
                    return true; // Succ√®s
                    
                } else {
                    console.warn("[FETCH_PLAYERS_IN_SESSION] √âchec cibl√©. Le serveur n'a pas encore mis √† jour l'√©tat.");
                    return false; // √âchec
                }
                
            } catch (e) {
                console.error("Erreur r√©seau ou JSON lors de la r√©cup√©ration cibl√©e:", e);
                return false; // √âchec
            }
        }
        async function fetchGameData() {
            const sessionCode = document.getElementById('sessionCode').textContent;
            const scoreCounter = document.getElementById('scoreCounter');

            if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
                return;
            }

            try {
                // 1. Mise √† jour du score
                const scoreResponse = await fetch(`${API_URL}/get_poires?session=${encodeURIComponent(sessionCode)}`);
                const scoreData = await scoreResponse.json();
                
                if (scoreData.status === "success" && scoreCounter) {
                    const currentScore = parseInt(scoreCounter.textContent) || 0;
                    const newScore = scoreData.poires || 0;
                    
                    const steps = 10;
                    const diff = newScore - currentScore;
                    const stepValue = diff / steps;
                    for (let i = 1; i <= steps; i++) {
                        const value = Math.round(currentScore + stepValue * i);
                        setTimeout(() => {
                            scoreCounter.textContent = value;
                        }, i * 100); 
                    }
                }
                
                // 2. Mise √† jour des joueurs
                await fetchPlayers();

            } catch (e) {
                console.error("Erreur lors du rafra√Æchissement des donn√©es:", e);
            }
        }

        function checkCloseButtonState() {
            const sessionCode = document.getElementById('sessionCode').textContent;
            const closeBtn = document.getElementById('closeBtn');

            // 1. D√©sactivation pour les √©tats transitoires ou non connect√©s
            if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
                closeBtn.disabled = true;
                closeBtn.style.backgroundColor = "#6b7280";
                closeBtn.style.cursor = "not-allowed";
                closeBtn.textContent = "√ó";
                return;
            }

            // 2. üöÄ Activation pour toutes les sessions valides (y compris les sessions de groupe)
            // Le bouton doit √™tre ACTIF, car handleLeaveSession() g√®re la logique complexe 
            // (si c'est le cr√©ateur ou un simple joueur, etc.)
            closeBtn.disabled = false;
            closeBtn.style.backgroundColor = ""; // Retirer le style de d√©sactivation
            closeBtn.style.cursor = "pointer"; // R√©tablir le curseur normal
            closeBtn.textContent = "‚úñ"; // Changer le texte pour indiquer qu'il est cliquable (ou garder '√ó')
            }
            getPlayerSessionInfo().then(sessionInfo => {
                 const isCreator = sessionInfo && sessionInfo.creator === username && sessionInfo.session_code === sessionCode;
                 const isInGroup = sessionInfo && sessionInfo.session_code === sessionCode && !isCreator;
                
                if (isCreator) {
                    // Le cr√©ateur ne peut pas faire /leave, il doit faire /logout (‚Üê)
                    closeBtn.disabled = true; 
                    closeBtn.style.backgroundColor = "#6b7280"; 
                    closeBtn.style.cursor = "not-allowed";
                } else if (isInGroup) {
                    // Joueur dans une session de groupe, peut /leave
                    closeBtn.disabled = false; 
                    closeBtn.style.backgroundColor = "#ef4444";
                    closeBtn.style.cursor = "pointer";
                } else {
                    // Joueur dans sa session solo, pas de bouton actif
                    closeBtn.disabled = true; 
                    closeBtn.style.backgroundColor = "#6b7280"; 
                    closeBtn.style.cursor = "not-allowed";
                }
                closeBtn.textContent = "√ó";
            });

        function updatePlayersList(players, creator) {
            // üí° D√©finissez le pseudo de l'administrateur ici. √Ä remplacer par le pseudo r√©el !
            const ADMIN_USERNAME = 'admin'; 

            // 1. R√©cup√©ration des √©l√©ments DOM
            const playerCount = document.getElementById('playerCount');
            const playerSlots = [
                document.getElementById('player1'), 
                document.getElementById('player2'), 
                document.getElementById('player3'), 
                document.getElementById('player4'), 
                document.getElementById('player5')
            ];
            if (!playerCount || playerSlots.length === 0 || !playerSlots[0]) return;

            // R√©cup√©ration du nom d'utilisateur actuel (celui qui regarde l'√©cran)
            const username = localStorage.getItem("username"); 

            // --- Gestion de l'Unicit√© des Joueurs ---
            
            const uniqueActivePlayersSet = new Set();
            
            // Ajout du cr√©ateur
            if (creator) {
                uniqueActivePlayersSet.add(creator);
            }
            
            // Ajout de la liste des joueurs re√ßue du serveur
            if (players && Array.isArray(players)) {
                players.forEach(p => uniqueActivePlayersSet.add(p));
            }
            
            // Ajout de l'utilisateur actuel (au cas o√π il ne serait pas explicitement list√©)
            if (username) {
                uniqueActivePlayersSet.add(username); 
            }

            // Conversion en Array et limitation √† 5 joueurs
            let uniqueActivePlayers = Array.from(uniqueActivePlayersSet).slice(0, 5);
            
            // --- Mise √† Jour de l'Affichage ---
            
            playerCount.textContent = `${uniqueActivePlayers.length}/5`;

            playerSlots.forEach((slot, index) => {
                const player = uniqueActivePlayers[index];
                
                if (slot) {
                    // Nettoyage et r√©initialisation du slot pour le rafra√Æchissement
                    slot.className = 'player-item'; 
                    slot.textContent = ''; 

                    if (player) {
                        // D√©termination des r√¥les
                        const isCreator = player === creator;
                        const isMe = player === username;
                        const isAdmin = player === ADMIN_USERNAME;
                        
                        let displayString = player; // Par d√©faut, le pseudo du joueur
                        let emoji = 'üë§'; // Emoji par d√©faut (Joueur standard)

                        // 1. D√©termination de l'Emoji (Priorit√© : Cr√©ateur > Admin > Joueur)
                        if (isCreator) {
                            emoji = 'üëë'; // Cr√©ateur
                            slot.classList.add('player-item-creator');
                        } else if (isAdmin) {
                            emoji = 'ü§ñ'; // Administrateur
                            slot.classList.add('player-item-admin');
                        } 
                        // Sinon, l'emoji reste üë§ (Joueur standard)

                        // 2. D√©termination du Texte √† Afficher
                        if (isMe) {
                            displayString = 'Vous'; 
                            slot.classList.add('player-item-me');
                        }
                        
                        // 3. Affichage final
                        slot.textContent = `${emoji} ${displayString}`;
                        
                    } else {
                        // Slot vide / En attente
                        slot.textContent = '‚ö™ En attente...';
                        slot.classList.add('waiting');
                    }
                }
            });
        }
        async function createSession(sessionCode) {
            const sessionCodeElement = document.getElementById('sessionCode');
            const sidebarStatus = document.getElementById('sidebarStatus');
            sessionCodeElement.textContent = "Cr√©ation...";
            sidebarStatus.textContent = `Cr√©ation de la session : ${sessionCode}...`;
            sidebarStatus.style.color = "#60a5fa";

            try {
                const response = await fetch(`${API_URL}/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: sessionCode, id: username })
                });
                const data = await response.json();

                if (data.status === "success") {
                    console.log(`[INIT] Session personnelle cr√©√©e : ${data.session_name}`);
                    sessionCodeElement.textContent = data.session_name;
                    sidebarStatus.textContent = "‚úÖ Session personnelle pr√™te.";
                    sidebarStatus.style.color = "#10b981";
                    return true;
                } else {
                    console.error(`[INIT] √âchec de cr√©ation : ${data.message}`);
                    sessionCodeElement.textContent = "Erreur";
                    sidebarStatus.textContent = `‚ùå √âchec de cr√©ation : ${data.message}`;
                    sidebarStatus.style.color = "#ef4444";
                    return false;
                }
            } catch (e) {
                console.error("[INIT] Erreur r√©seau lors de la cr√©ation de session:", e);
                sessionCodeElement.textContent = "Erreur";
                sidebarStatus.textContent = "‚ùå Erreur r√©seau. V√©rifiez l'API.";
                sidebarStatus.style.color = "#ef4444";
                return false;
            }
        }

        async function loadMySession() {
            const sessionCodeElement = document.getElementById('sessionCode');
            const sidebarStatus = document.getElementById('sidebarStatus');
            sessionCodeElement.textContent = "Chargement...";
            sidebarStatus.textContent = "Recherche de la session personnelle...";
            sidebarStatus.style.color = "#94a3b8";
            
            try {
                const sessionInfo = await getPlayerSessionInfo();

                if (sessionInfo && sessionInfo.session_code) {
                     console.log(`[INIT] Session trouv√©e : ${sessionInfo.session_code}`);
                     sessionCodeElement.textContent = sessionInfo.session_code;
                     sidebarStatus.textContent = "‚úÖ Session personnelle charg√©e.";
                     sidebarStatus.style.color = "#10b981";
                     return true;
                }
                
                sessionCodeElement.textContent = "Aucune session";
                return await createSession(username);

            } catch (e) {
                console.error("[INIT] Erreur lors du chargement de session:", e);
                sessionCodeElement.textContent = "Erreur";
                sidebarStatus.textContent = "‚ùå Erreur critique lors du chargement.";
                sidebarStatus.style.color = "#ef4444";
                return false;
            }
        }

        function launchGameCycle() {
             startScoreInterval(3);
             startClicksInterval();
        }

        // --- INITIALISATION ---
        
        function init() {
            if (!username) {
                console.error("Nom d'utilisateur non trouv√©. Redirection.");
                window.location.href = 'index.html';
                return;
            }
            
            document.getElementById('usernameLabel').textContent = `üë§ ${username}`;
            document.getElementById('clickButton').addEventListener('click', onCLickerClick);
            document.getElementById('joinButton').addEventListener('click', () => handleJoinSession('joinInput'));
            document.getElementById('closeBtn').addEventListener('click', handleLeaveSession);
            
            document.getElementById('joinButtonMobile').addEventListener('click', () => handleJoinSession('joinInputMobile'));
            document.getElementById('joinInputMobile').addEventListener('keyup', (event) => {
                 if (event.key === 'Enter') handleJoinSession('joinInputMobile');
            });
            document.getElementById('joinInput').addEventListener('keyup', (event) => {
                 if (event.key === 'Enter') handleJoinSession('joinInput');
            });
            
            document.getElementById('toggleSidebar').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                const toggleBtn = document.getElementById('toggleSidebar');
                sidebar.classList.toggle('hidden');
                toggleBtn.classList.toggle('open');
            });
            
            window.addEventListener('beforeunload', handleLogoutOnClose);

            loadMySession().then(success => {
                if (success) {
                    launchGameCycle();
                } else {
                    stopAllCycles();
                }
            });
        }

        init();
    </script>
</body>
</html>