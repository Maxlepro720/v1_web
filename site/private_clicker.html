<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Clicker Game</title>
    <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #232323; overflow: hidden; }

    .container { display: flex; width: 100vw; height: 100vh; position: relative; overflow: hidden; }

    .main-area { flex: 1; background: #1b1b1b; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; position: relative; min-width: 0; }

    .title { color: #ffffff; font-size: clamp(32px, 6vw, 60px); font-weight: bold; margin-bottom: 15px; text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }

    .score-counter { color: #ffffff; font-size: clamp(20px, 3vw, 32px); font-weight: bold; margin-bottom: 10px; text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); background: rgba(255, 255, 255, 0.1); padding: 8px 25px; border-radius: 20px; backdrop-filter: blur(10px); }

    .to-send { color: #ffffff; font-size: clamp(14px, 2vw, 20px); margin-bottom: 30px; opacity: 0.9; }

    .click-button { width: min(30vh, 30vw, 220px); height: min(30vh, 30vw, 220px); max-width: 220px; max-height: 220px; aspect-ratio: 1/1; border-radius: 50%; background: linear-gradient(145deg, #ffd966, #ffb84d); border: 6px solid #ff6b35; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 10px 30px rgba(255, 107, 53, 0.4); position: relative; overflow: hidden; flex-shrink: 0; }

    .click-button::before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; height: 85%; border-radius: 50%; background-size: cover; background-position: center; }

    .click-button:hover { transform: scale(1.1); box-shadow: 0 15px 40px rgba(255, 107, 53, 0.6); }

    .click-button:active { transform: scale(0.95); box-shadow: 0 5px 20px rgba(255, 107, 53, 0.3); }

    .timer-counter { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #FFFFFF; font-size: clamp(12px, 1.5vw, 16px); font-weight: bold; background: rgba(0, 0, 0, 0.3); padding: 10px 25px; border-radius: 30px; backdrop-filter: blur(10px); min-width: 200px; max-width: 90%; text-align: center; }

    .timer-bar { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); width: min(250px, 80%); height: 4px; background: rgba(255, 255, 255, 0.2); border-radius: 2px; overflow: hidden; }

    .timer-bar-fill { height: 100%; background: linear-gradient(90deg, #10b981, #3b82f6); border-radius: 2px; transition: width 0.1s linear; }

    .status-label { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #FFFFFF; font-size: clamp(11px, 1.5vw, 14px); padding: 6px 14px; border-radius: 8px; background: rgba(0, 0, 0, 0.5); max-width: 90%; text-align: center; }

    .sidebar { width: clamp(280px, 30vw, 350px); max-width: 100vw; background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%); padding: 20px; position: absolute; right: 0; top: 0; height: 100vh; transform: translateX(0); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 100; overflow-y: auto; box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3); }

    .sidebar.hidden { transform: translateX(100%); }

    .toggle-sidebar-btn { position: fixed; top: 20px; right: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; width: clamp(40px, 6vw, 50px); height: clamp(40px, 6vw, 50px); border-radius: 50%; cursor: pointer; font-size: clamp(18px, 3vw, 24px); z-index: 101; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); display: flex; align-items: center; justify-content: center; }

    .toggle-sidebar-btn:hover { transform: scale(1.1); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); }

    .close-btn { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; width: clamp(35px, 5vw, 40px); height: clamp(35px, 5vw, 40px); border-radius: 12px; cursor: pointer; font-size: clamp(18px, 3vw, 24px); font-weight: bold; position: absolute; top: 20px; right: 20px; transition: all 0.2s ease; box-shadow: 0 2px 10px rgba(239, 68, 68, 0.3); display: flex; align-items: center; justify-content: center; }

    .close-btn:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 4px 15px rgba(239, 68, 68, 0.5); }

    .close-btn:disabled { background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); cursor: not-allowed; opacity: 0.6; }

    .sidebar-title { color: #f8fafc; font-size: clamp(20px, 3vw, 28px); font-weight: bold; margin-bottom: 25px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }

    .section-title { color: #cbd5e1; font-size: clamp(11px, 1.5vw, 13px); font-weight: bold; margin-top: 20px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }

    .session-code { color: #60a5fa; font-size: clamp(22px, 3.5vw, 32px); font-weight: bold; margin-bottom: 18px; text-shadow: 0 2px 8px rgba(96, 165, 250, 0.3); word-break: break-all; }

    .username-label, .player-count { color: #f8fafc; font-size: clamp(14px, 2vw, 16px); margin-bottom: 10px; }

    .player-item { color: #10b981; font-size: clamp(13px, 1.8vw, 15px); margin: 8px 0; padding: 8px 12px; background: rgba(16, 185, 129, 0.1); border-radius: 10px; border-left: 3px solid #10b981; transition: all 0.3s ease; word-break: break-word; }

    .player-item:hover { background: rgba(16, 185, 129, 0.2); transform: translateX(5px); }

    .player-item.waiting { color: #64748b; background: rgba(100, 116, 139, 0.1); border-left: 3px solid #64748b; }

    .join-input { width: 100%; height: clamp(40px, 5vh, 45px); border-radius: 12px; border: 2px solid #475569; background: rgba(51, 65, 85, 0.6); color: #f8fafc; padding: 0 14px; font-size: clamp(13px, 1.8vw, 15px); margin-top: 10px; transition: all 0.3s ease; backdrop-filter: blur(5px); }

    .join-input:focus { outline: none; border-color: #60a5fa; background: rgba(51, 65, 85, 0.8); box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2); }

    .join-input::placeholder { color: #94a3b8; }

    .join-button { width: 100%; height: clamp(42px, 5.5vh, 48px); border-radius: 12px; border: none; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; font-size: clamp(13px, 1.8vw, 15px); font-weight: bold; cursor: pointer; margin-top: 12px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); }

    .join-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); }

    .join-button:active { transform: translateY(0); }

    .upgrade-button { width: 100%; height: clamp(42px, 5.5vh, 48px); border-radius: 12px; border: none; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; font-size: clamp(13px, 1.8vw, 15px); font-weight: bold; cursor: pointer; margin-top: 12px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3); }

    .upgrade-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4); background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); }

    .upgrade-button:active { transform: translateY(0); }

    .sidebar-status { color: #94a3b8; font-size: clamp(11px, 1.5vw, 12px); margin-top: 10px; min-height: 20px; word-break: break-word; }

    .back-btn { position: absolute; top: 20px; left: 20px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; width: clamp(40px, 6vw, 50px); height: clamp(40px, 6vw, 50px); border-radius: 50%; cursor: pointer; font-size: clamp(18px, 3vw, 24px); display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); transition: all 0.3s ease; z-index: 102; }

    .back-btn:hover { transform: scale(1.1); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6); }


    /* Joueur en attente */
    /* Style par d√©faut pour un joueur */
    .player-item {
        padding: 8px;
        margin-bottom: 5px;
        border-radius: 4px;
        background-color: #374151; /* Gris fonc√© */
        border-left: 3px solid #10b981; /* Vert par d√©faut */
        transition: all 0.2s ease-in-out;
    }

    /* Joueur en attente */
    .player-item.waiting {
        color: #64748b;
        background: #1f2937; /* Gris tr√®s fonc√© */
        border-left: 3px solid #64748b; /* Gris */
    }

    /* L'utilisateur courant */
    .player-item-me {
        font-weight: bold;
        color: #fcd34d; /* Jaune/Or */
        border-left: 3px solid #fcd34d; 
        background: #3f3f46; 
    }

    /* Le cr√©ateur de la session (la couronne üëë) */
    .player-item-creator {
        color: #ff6b35; /* Rouge/Orange */
        border-left: 3px solid #ff6b35; 
        /* Ce style peut √™tre combin√© avec player-item-me si l'utilisateur est le cr√©ateur */
    }

    /* Le cr√©ateur de la session */
    .player-item-creator {
        color: #ff6b35; /* Rouge/Orange */
        border-left: 3px solid #ff6b35; 
        background: rgba(255, 107, 53, 0.15); 
    }

    @media (max-width: 768px) {
        .sidebar { width: 85vw; }
        .main-area { padding: 15px; }
        .click-button { width: min(40vw, 40vh, 200px); height: min(40vw, 40vh, 200px); }
    }

    @media (max-width: 480px) {
        .sidebar { width: 90vw; }
        .click-button { width: min(50vw, 45vh, 180px); height: min(50vw, 45vh, 180px); }
    }
</style>

</head>
<body>
    <div class="container">
        <div class="main-area">
            <button class="back-btn" onclick="handleBackButton()">‚Üê</button>

            <div class="title">Clicker</div>
            <div class="score-counter" id="scoreCounter">0</div> 
            <div class="to-send" id="toSend">-- 0 --</div>
            <button class="click-button" id="clickButton"></button>
            <div class="timer-bar">
                <div class="timer-bar-fill" id="timerBarFill"></div>
            </div>
            <div class="timer-counter" id="timerCounter">Rafra√Æchissement : lancement</div>
            <div class="status-label" id="statusLabel"></div>
        </div>

        <button class="toggle-sidebar-btn" id="toggleSidebar">‚ò∞</button>

        <div class="sidebar" id="sidebar">
            <button class="close-btn" id="closeBtn">√ó</button>
            <div class="sidebar-title">Session</div>

            <div class="section-title">Code de session</div>
            <div class="session-code" id="sessionCode">Chargement...</div>

            <div class="section-title">Utilisateur</div>
            <div class="username-label" id="usernameLabel">Utilisateur</div>

            <div class="section-title">Joueurs pr√©sents</div>
            <div class="player-count" id="playerCount">1/5</div>

            <div id="playersList">
                <div class="player-item" id="player1">üë§ Vous</div>
                <div class="player-item waiting" id="player2">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player3">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player4">‚ö™ En attente...</div>
                <div class="player-item waiting" id="player5">‚ö™ En attente...</div>
            </div>

            <div class="section-title">Rejoindre une session</div>
            <input type="text" class="join-input" id="joinInput" placeholder="Entrer un code">
            <button class="join-button" id="joinButton">Rejoindre</button>
            <a href="upgrade.html" target="_blank"><button class="upgrade-button" id="upgradeButton">‚ö° Am√©lioration</button></a>

            <div class="sidebar-status" id="sidebarStatus"></div>
        </div>
    </div>

   <script>
    // --- VARIABLES GLOBALES ET CONSTANTES ---
    const API_URL = "https://project-3-api-2bgb.onrender.com";
    
    // Fr√©quences pour les cycles
    const SCORE_REFRESH_PERIOD_SECONDS = 10; // Cycle FIXE pour Score total, Joueurs ET r√©initialisation de l'affichage des clics
    const CLICKS_MIN_SECONDS = 4;            // Minimum pour l'envoi des clics au serveur
    const CLICKS_MAX_SECONDS = 8;            // Maximum pour l'envoi des clics au serveur
    
    let clickCount = 0; // Clics cumul√©s depuis la derni√®re r√©initialisation/envoi
    let lastClickTime = 0;
    let clickIntervals = [];
    let username = localStorage.getItem("username"); // R√©cup√®re le nom d'utilisateur du stockage local

    let timerInterval;      // Intervalle pour l'affichage du timer du score (10s)
    let clicksTimeout;      // Timeout pour l'envoi al√©atoire des clics (4-8s)

    // --- FONCTIONS DE GESTION DES CYCLES ET DE L'√âTAT ---
    
    function stopAllCycles() {
        clearInterval(timerInterval);
        clearTimeout(clicksTimeout);
    }
    
    function stopClicksInterval() {
        clearTimeout(clicksTimeout);
    }
    
    function startClicksInterval() {
        stopClicksInterval(); 
        
        const duration = Math.floor(Math.random() * (CLICKS_MAX_SECONDS - CLICKS_MIN_SECONDS + 1)) + CLICKS_MIN_SECONDS;
        
        clicksTimeout = setTimeout(sendClicksRandomly, duration * 1000);
        console.log(`[CLICS] Prochain envoi al√©atoire de clics dans : ${duration}s`);
    }

    function startScoreInterval() {
        clearInterval(timerInterval);
        let timeLeft = SCORE_REFRESH_PERIOD_SECONDS; 
        updateDisplay(timeLeft); 

        timerInterval = setInterval(() => {
            timeLeft--;
            updateDisplay(timeLeft); 
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                gameCycle(); 
            }
        }, 1000); 
    }

    // Fonction principale du cycle de jeu (R√©cup√©ration du score et des joueurs / R√©initialisation de l'affichage des clics)
    async function gameCycle() {
        const sessionCode = document.getElementById('sessionCode').textContent;
         if (sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Chargement..." || sessionCode === "Cr√©ation...") {
            console.warn("[SCORE] Session invalide ou perdue. Tentative de reconnexion...");
            stopAllCycles();
            const sessionLoaded = await loadMySession();
            if (sessionLoaded) {
                startScoreInterval();
                startClicksInterval();
            }
            return;
         }
        
        const counterElement = document.getElementById('timerCounter');
        if (counterElement) {
            counterElement.textContent = "‚è≥";
        }

        // 1. R√©cup√®re les donn√©es (Score + Joueurs)
        await fetchGameData();
        
        // 2. R√©initialisation de l'AFFICHAGE des clics cumul√©s (pour l'utilisateur)
        const toSend = document.getElementById('toSend');
        if (toSend) toSend.textContent = "-- 0 --";
        
        // 3. Relance le timer du score
        startScoreInterval(); 
    }

    // --- FONCTIONS DE COMMUNICATION ET DE JEU ---

    /**
     * Tente de d√©connecter l'utilisateur du serveur de mani√®re fiable et silencieuse.
     * Utilis√© lors de la fermeture de la fen√™tre ou du changement de page.
     */
    function logoutSilently() {
        console.log("[LOGOUT] D√©connexion silencieuse...");
        stopAllCycles();

        // Utilise l'API Beacon (plus fiable pour les √©v√©nements 'unload'/'beforeunload')
        if (navigator.sendBeacon) {
            navigator.sendBeacon(`${API_URL}/logout`, JSON.stringify({ id: username }));
            return;
        }

        // Fallback pour les navigateurs plus anciens ou si Beacon √©choue
        try {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", `${API_URL}/logout`, false); // Synchrone, bloquant
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.send(JSON.stringify({ id: username }));
        } catch (e) {
            console.error("Erreur lors du logout silencieux (XHR):", e);
        }
    }
    
    /**
     * G√®re le clic sur le bouton de retour.
     */
    function handleBackButton() {
        logoutSilently(); // Se d√©connecte avant de partir
        // Redirige vers la page de login/accueil (doit exister)
        window.location.href = 'index.html'; 
    }

    /**
     * G√®re le clic sur le bouton 'X' (Quitter la session).
     */
    async function handleLeaveSession() {
        const sessionCode = document.getElementById('sessionCode').textContent;
        const sidebarStatus = document.getElementById('sidebarStatus');
        const closeBtn = document.getElementById('closeBtn');

        // V√©rification de l'√©tat (si l'utilisateur est cr√©ateur, il ne peut pas quitter)
        if (closeBtn.disabled) {
            sidebarStatus.textContent = "‚ö†Ô∏è Cr√©ateur : fermer la session via le serveur ou quitter le jeu.";
            sidebarStatus.style.color = "#f59e0b";
            return;
        }
        
        if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
            sidebarStatus.textContent = "‚ö†Ô∏è Pas de session active √† quitter.";
            sidebarStatus.style.color = "#f59e0b";
            return;
        }

        try {
            closeBtn.disabled = true; 
            sidebarStatus.textContent = `Tentative de quitter la session ${sessionCode}...`;
            sidebarStatus.style.color = "#f59e0b";

            const response = await fetch(`${API_URL}/leave`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ code: sessionCode, id: username })
            });
            const data = await response.json();

            if (data.status === "success") {
                sidebarStatus.textContent = "‚úÖ Session quitt√©e avec succ√®s.";
                sidebarStatus.style.color = "#10b981";
                stopAllCycles();
                await loadMySession(); // Recharge la session personnelle
                // Red√©marre les cycles apr√®s le rechargement
                await fetchGameData();
                launchGameCycle(); 
            } else {
                sidebarStatus.textContent = `‚ùå Impossible de quitter : ${data.message}`;
                sidebarStatus.style.color = "#ef4444";
            }
        } catch (e) {
            sidebarStatus.textContent = "‚ùå Erreur r√©seau lors de la d√©connexion de session.";
            sidebarStatus.style.color = "#ef4444";
        } finally {
            checkCloseButtonState(); // R√©tablit l'√©tat du bouton
        }
    }

    function onCLickerClick() {
        const statusLabel = document.getElementById('statusLabel'); 
        const toSend = document.getElementById('toSend'); 
        
        const now = Date.now() / 1000;
        let freq = 0;
        
        // Calcul de la fr√©quence de clic (pour la d√©tection de l'autoclicker)
        if (lastClickTime !== 0) {
            const interval = now - lastClickTime;
            clickIntervals.push(interval);
            if (clickIntervals.length > 5) clickIntervals.shift();
            const avg = clickIntervals.reduce((a, b) => a + b, 0) / clickIntervals.length;
            const clickFrequency = avg > 0 ? 1 / avg : 0;
            freq = clickFrequency; 
        }
        lastClickTime = now;

        if (freq > 20) { 
            if (statusLabel) {
                statusLabel.textContent = "‚ö†Ô∏è Autoclicker d√©tect√© ‚ö†Ô∏è";
                statusLabel.style.color = "#f87171";
                setTimeout(() => { statusLabel.textContent = "", statusLabel.style.color = "#FFFFFF"; }, 1000);
            }
            return;
        }

        clickCount++;
        // Mise √† jour de l'affichage des clics cumul√©s
        if (toSend) toSend.textContent = `-- ${clickCount} --`;
    }
    
    // Envoie les clics et relance le timer al√©atoire (4-8s)
    async function sendClicksRandomly() {
        const sessionCode = document.getElementById('sessionCode').textContent;
        
        if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
            startClicksInterval();
            return;
        }
        
        const toSendValue = clickCount;
        
        // R√©initialisation de la valeur de la variable clickCount APR√àS lecture
        clickCount = 0; 
        
        try {
            if (toSendValue > 0) {
                await fetch(`${API_URL}/poire`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ session: sessionCode, click: toSendValue, id: username }) 
                });
                console.log(`[CLICS] Clicks envoy√©s : ${toSendValue}`);
            }
        } catch (e) {
            const statusLabel = document.getElementById('statusLabel');
            if (statusLabel) {
                statusLabel.textContent = "‚ùå Erreur r√©seau envoi";
                statusLabel.style.color = "#ef4444";
            }
        } finally {
            startClicksInterval(); // Relance le timer al√©atoire apr√®s l'envoi
        }
    }

    // V√©rifie et met √† jour l'√©tat du bouton "Quitter" (pour emp√™cher le cr√©ateur de quitter)
    async function checkCloseButtonState() {
        const sessionCode = document.getElementById('sessionCode').textContent;
        const closeBtn = document.getElementById('closeBtn');

        if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
            closeBtn.disabled = true;
            closeBtn.style.backgroundColor = "grey";
            closeBtn.style.cursor = "not-allowed";
            return;
        }

        try {
            // Utilise /verify_session pour savoir si l'utilisateur est le cr√©ateur
            const response = await fetch(`${API_URL}/verify_session?id=${encodeURIComponent(username)}`);
            const data = await response.json();

            if (data.status === "success" && data.creator === username) {
                // Cr√©ateur : ne peut pas quitter
                closeBtn.disabled = true;
                closeBtn.style.backgroundColor = "#6b7280"; // Gris
                closeBtn.style.cursor = "not-allowed";
            } else {
                // Simple joueur : peut quitter
                closeBtn.disabled = false;
                closeBtn.style.backgroundColor = "#ef4444"; // Rouge (Couleur Quitter)
                closeBtn.style.cursor = "pointer";
            }

        } catch (e) {
            console.error("[Info] Erreur v√©rification leave button :", e);
            closeBtn.disabled = true;
        }
    }


    // R√©cup√®re la liste des joueurs et v√©rifie la session
    async function fetchPlayers() {
        const sessionCodeElement = document.getElementById('sessionCode');
        const sessionCode = sessionCodeElement.textContent;
        if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
            return;
        }

        try {
            // R√©cup√®re les donn√©es de session (nom, joueurs, cr√©ateur)
            const playersResponse = await fetch(`${API_URL}/verify_session?id=${encodeURIComponent(username)}`);
            const playersData = await playersResponse.json();
            
            if (playersData.status === "success" && playersData.session_code) {
                // Important: Mettre √† jour le code de session au cas o√π l'utilisateur a rejoint une nouvelle
                sessionCodeElement.textContent = playersData.session_code; 
                
                // Correction ici: On passe la liste des joueurs et le cr√©ateur √† la fonction d'affichage
                updatePlayersList(playersData.players || [], playersData.creator);
                
                checkCloseButtonState(); 

            } else if (playersData.status === "error" && playersData.message.includes("Session invalide")) {
                 // Si la session du joueur n'existe plus
                console.error("[PLAYERS] Session invalide d√©tect√©e. Tentative de rechargement...");
                stopAllCycles();
                await loadMySession();
                launchGameCycle(); 
            }
        } catch (e) {
            console.error("Erreur lors du rafra√Æchissement des joueurs:", e);
        }
    }

    // R√©cup√®re le score total et appelle fetchPlayers (Cycle de 10s)
    async function fetchGameData() {
        const sessionCode = document.getElementById('sessionCode').textContent;
        const scoreCounter = document.getElementById('scoreCounter');

        if (sessionCode === "Chargement..." || sessionCode === "Aucune session" || sessionCode === "Erreur" || sessionCode === "Cr√©ation...") {
            return;
        }

        try {
            // 1. Mise √† jour du score
            const scoreResponse = await fetch(`${API_URL}/get_poires?session=${encodeURIComponent(sessionCode)}`);
            const scoreData = await scoreResponse.json();
            
            if (scoreData.status === "success" && scoreCounter) {
                const currentScore = parseInt(scoreCounter.textContent) || 0;
                const newScore = scoreData.poires || 0;
                
                // Animation du score (facultatif mais plus agr√©able)
                const steps = 10;
                const diff = newScore - currentScore;
                const stepValue = diff / steps;
                for (let i = 1; i <= steps; i++) {
                    const value = Math.round(currentScore + stepValue * i);
                    setTimeout(() => {
                        scoreCounter.textContent = value;
                    }, i * 100); 
                }
            }
            
            // 2. Mise √† jour des joueurs (Synchro avec le score toutes les 10s)
            await fetchPlayers();

        } catch (e) {
            console.error("Erreur lors du rafra√Æchissement des donn√©es:", e);
        }
    }
    
    // Logique d'affichage des joueurs
    function updatePlayersList(players, creator) {
        const playerCount = document.getElementById('playerCount');
        const playerSlots = [
            document.getElementById('player1'), 
            document.getElementById('player2'), 
            document.getElementById('player3'), 
            document.getElementById('player4'), 
            document.getElementById('player5')
        ];
        if (!playerCount || !playerSlots[0]) return;

        let uniqueActivePlayers = [];
        // 1. Ajoute le Cr√©ateur en premier
        if (creator && !uniqueActivePlayers.includes(creator)) uniqueActivePlayers.push(creator);
        
        // 2. Ajoute les autres joueurs de la liste 'players'
        if (players) {
            players.forEach(p => {
                 if (!uniqueActivePlayers.includes(p)) {
                    uniqueActivePlayers.push(p);
                }
            });
        }
        
        // 3. Assure que l'utilisateur courant est dans la liste
        if (username && !uniqueActivePlayers.includes(username)) {
            uniqueActivePlayers.push(username); 
        }

        // Finalise la liste et la limite √† 5
        uniqueActivePlayers = [...new Set(uniqueActivePlayers)].slice(0, 5);
        
        playerCount.textContent = `${uniqueActivePlayers.length}/5`;

        playerSlots.forEach((slot, index) => {
            const player = uniqueActivePlayers[index];
            if (slot) {
                // R√©initialise les classes
                slot.className = 'player-item'; 

                if (player) {
                    let displayString = "";
                    const isCreator = player === creator;
                    const isMe = player === username;
                    
                    if (isMe) {
                        displayString = isCreator ? `üëë üë§ Vous` : `üë§ Vous`; 
                        slot.classList.add('player-item-me');
                        if (isCreator) slot.classList.add('player-item-creator'); 
                    } else {
                        displayString = isCreator ? `üëë ${player}` : `üë§ ${player}`;
                        if (isCreator) slot.classList.add('player-item-creator');
                    }
                    
                    slot.textContent = displayString;
                } else {
                    slot.textContent = "‚ö™ En attente...";
                    slot.classList.add('waiting'); // Style gris/attente
                }
            }
        });
    }


    // Met √† jour le compteur et la barre de progression (Cycle du score fixe)
    function updateDisplay(timeLeft) {
        const counterElement = document.getElementById('timerCounter');
        const barElement = document.getElementById('timerBarFill');
        
        const timeElapsed = SCORE_REFRESH_PERIOD_SECONDS - timeLeft;
        const percentage = (timeElapsed / SCORE_REFRESH_PERIOD_SECONDS) * 100;

        if (counterElement) {
            counterElement.textContent = `Rafra√Æchissement : ${timeLeft} sec`; 
        }
        
        if (barElement) {
            barElement.style.width = `${percentage}%`;
        }
    }

    // Tente de cr√©er une session. Utilis√© si aucune session n'est trouv√©e.
    async function createSession() {
        const sessionCode = document.getElementById('sessionCode');
        const sidebarStatus = document.getElementById('sidebarStatus');
        if (!sessionCode || !sidebarStatus) return false;
        
        sessionCode.textContent = "Cr√©ation...";
        
        try {
            const response = await fetch(`${API_URL}/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: username })
            });
            const data = await response.json();

            if (data.status === "success" && data.session_name) {
                sessionCode.textContent = data.session_name;
                sidebarStatus.textContent = "üéâ Session cr√©√©e";
                sidebarStatus.style.color = "#10b981";
                return true;
            } else {
                sessionCode.textContent = "Erreur";
                sidebarStatus.textContent = "‚ùå Erreur de cr√©ation : " + (data.message || "Inconnue");
                sidebarStatus.style.color = "#ef4444"; 
                return false;
            }
        } catch (e) {
            sessionCode.textContent = "Erreur";
            sidebarStatus.textContent = "‚ùå Erreur r√©seau lors de la cr√©ation";
            sidebarStatus.style.color = "#ef4444";
            return false;
        }
    }

    /**
     * Tente de charger la session personnelle de l'utilisateur.
     * Si aucune n'existe, en cr√©e une.
     */
    async function loadMySession() {
        const sessionCode = document.getElementById('sessionCode');
        const sidebarStatus = document.getElementById('sidebarStatus');
        if (!sessionCode || !sidebarStatus) return false;

        sessionCode.textContent = "Chargement...";
        
        try {
            // 1. Tente de r√©cup√©rer la session existante
            const response = await fetch(`${API_URL}/session?user=${encodeURIComponent(username)}`);
            const data = await response.json();
            
            if (data.status === "success" && data.code) {
                sessionCode.textContent = data.code;
                sidebarStatus.textContent = "‚úÖ Session personnelle charg√©e";
                sidebarStatus.style.color = "#10b981";
                return true;
            } else {
                // 2. Si non trouv√©e ou erreur, tente d'en cr√©er une
                return await createSession(); 
            }
        } catch (e) {
            // 3. En cas d'erreur r√©seau, tente de cr√©er une session (si /session a √©chou√©)
            return await createSession(); 
        }
    }

    // Fonction utilitaire pour lancer le cycle apr√®s le d√©lai UTC
    function launchGameCycle() {
        startClicksInterval();

        // Calcule le temps restant jusqu'au prochain multiple de 10 secondes (pour la synchro)
        const now = new Date();
        const utcSeconds = now.getUTCSeconds(); 
        const elapsed = utcSeconds % SCORE_REFRESH_PERIOD_SECONDS;
        const waitTimeSeconds = SCORE_REFRESH_PERIOD_SECONDS - elapsed;
        
        console.log(`[INIT] Attente avant le premier cycle du score (Synchro 10s) : ${waitTimeSeconds.toFixed(2)}s`);

        // Lance le cycle du score (10s fixe) au prochain multiple de 10
        setTimeout(() => {
            gameCycle(); 
        }, (waitTimeSeconds * 1000) - 50); 
    }
    
    // --- EX√âCUTION AU CHARGEMENT DE LA PAGE ---
    
    document.addEventListener('DOMContentLoaded', () => {
        
        // --- V√©rification critique du nom d'utilisateur ---
        if (!username || username.trim() === "" || username === "null" || username.toLowerCase() === "chargement..." || username.toLowerCase() === "erreur") {
            document.body.innerHTML = '<h1>‚ùå Erreur: Nom d\'utilisateur manquant.</h1><p>Veuillez vous connecter √† nouveau.</p><button onclick="window.location.href=\'index.html\'">Accueil</button>';
            stopAllCycles();
            return;
        }

        const clickButton = document.getElementById('clickButton');
        const usernameLabel = document.getElementById('usernameLabel');
        const joinInput = document.getElementById('joinInput');
        const joinButton = document.getElementById('joinButton');
        const sidebar = document.getElementById('sidebar');
        const toggleSidebar = document.getElementById('toggleSidebar');
        const closeBtn = document.getElementById('closeBtn');

        if (usernameLabel) usernameLabel.textContent = username;

        // √âv√©nements
        if (document.querySelector('.back-btn')) document.querySelector('.back-btn').addEventListener('click', handleBackButton);
        if (closeBtn) closeBtn.addEventListener('click', handleLeaveSession);
        if (toggleSidebar && sidebar) toggleSidebar.addEventListener('click', () => { 
            sidebar.classList.toggle('hidden'); 
        });
        if (clickButton) clickButton.addEventListener('click', onCLickerClick);
        
        // D√©connexion lors de la fermeture de la fen√™tre
        window.addEventListener('unload', logoutSilently); 

        // Fonctionnalit√© de Rejoindre/Changer de session
        if (joinButton) joinButton.addEventListener('click', async () => {
            let input = joinInput.value.trim();
            const sidebarStatus = document.getElementById('sidebarStatus');
            const sessionCode = document.getElementById('sessionCode');
            if (!joinInput || !sidebarStatus || !sessionCode) return;
            
            joinButton.disabled = true;
            stopAllCycles(); 
            
            try {
                if (input.toLowerCase().startsWith("/cha ")) {
                    // --- Commande /cha (Changement de nom de session) ---
                    const newSessionName = input.substring(5).trim();
                    
                    if (!newSessionName) {
                        sidebarStatus.textContent = "‚ö†Ô∏è Nom de session manquant";
                        sidebarStatus.style.color = "#f59e0b";
                        return;
                    }

                    sidebarStatus.textContent = `Changement du nom en '${newSessionName}'...`;
                    const response = await fetch(`${API_URL}/change_session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id: username, new_session_name: newSessionName })
                    });
                    const data = await response.json();
                    
                    if (data.status === "success") {
                        sidebarStatus.textContent = `‚úÖ ${data.message}`;
                        sidebarStatus.style.color = "#10b981";
                        sessionCode.textContent = newSessionName;
                    } else {
                        sidebarStatus.textContent = `‚ùå Erreur changement : ${data.message}`;
                        sidebarStatus.style.color = "#ef4444";
                    }
                    
                } else if (!input) {
                    // --- Si vide, recharge la session personnelle ---
                    sidebarStatus.textContent = "Chargement de la session personnelle...";
                    await loadMySession(); 
                } else {
                    // --- Rejoint une session sp√©cifique (CORRIG√â) ---
                    sidebarStatus.textContent = `Tentative de rejoindre '${input}'...`;
                    sidebarStatus.style.color = "#f59e0b";
                    
                    const response = await fetch(`${API_URL}/join`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ code: input, id: username })
                    });
                    const data = await response.json();
                    
                    if (data.status === "success") {
                        // SUCC√àS : on met √† jour le code et on ne retourne PAS √† la session personnelle.
                        sidebarStatus.textContent = `‚úÖ Session '${input}' rejointe!`;
                        sidebarStatus.style.color = "#10b981";
                        sessionCode.textContent = input;
                        
                    } else {
                        // √âCHEC : on recharge la session personnelle pour revenir √† un √©tat connu et valide.
                        sidebarStatus.textContent = `‚ùå Erreur : ${data.message}`;
                        sidebarStatus.style.color = "#ef4444";
                        await loadMySession(); 
                    }
                }

                joinInput.value = "";
                // Red√©marre les cycles 
                await fetchGameData(); 
                launchGameCycle(); 

            } catch (e) {
                sidebarStatus.textContent = "‚ùå Erreur r√©seau lors de l'op√©ration";
                sidebarStatus.style.color = "#ef4444";
                await loadMySession();
                launchGameCycle(); 
            } finally {
                joinButton.disabled = false;
            }
        });

        // --- Lancement Initial S√âCURIS√â ---
        loadMySession().then((sessionLoaded) => {
            if (sessionLoaded) {
                // 1. Lance le premier fetch imm√©diatement pour remplir les donn√©es
                fetchGameData(); 
                // 2. D√©marre ensuite le cycle de 10s synchronis√©
                launchGameCycle(); 
            } else {
                console.error("Impossible de charger ou cr√©er une session. Le cycle ne d√©marrera pas.");
            }
        });
    });
</script>
</body>
</html>